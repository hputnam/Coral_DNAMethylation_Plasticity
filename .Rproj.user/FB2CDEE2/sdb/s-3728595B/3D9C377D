{
    "contents" : "##Examination of DNA Methylation and Phenotypic Plasticity in Corals\n#Data from Putnam NSF (NSF OCE PRF-1323822) and EPSCOR Y5 (NSF EPS-0903833)\n#last modified 20151021\n#See Readme file for details\n\nrm(list=ls()) # removes all prior objects\n\n#Read in required libraries\n##### Include Versions of libraries\nlibrary(\"car\") #levenes test\nlibrary(\"ggplot2\") #plotting\nlibrary(\"plotrix\") #plotting\nlibrary(\"reshape\") #data shaping\nlibrary(\"plyr\") #splitting, applying, and combining data\nlibrary(\"seacarb\") #seawater carbonate chemistry\nlibrary(\"vegan\") #calculating distance matrices\nlibrary(\"MetabolAnalyze\") #scaling function\nsource('/Users/hputnam/Publications/In_Prep/Primary/Bulk_Methylation/Coral_DNAMethylation_Plasticity/R_Analysis/Scripts/opls.R') #OPLS DA analysis script by Paul Anderson used in Sogin et al 2014 (http://birg.cs.cofc.edu/index.php/O-PLS)\nlibrary(\"pracma\") #OPLS DA analysis requirements\nlibrary(\"caret\") #OPLS DA analysis requirements\nrequire(\"gridExtra\") #Arrange Plots for output\n\n#Required Data files\n#BM_Acclimation.csv\n#BM_Field_Temp.csv\n#BM_Tank_Temp.csv\n#BM_Tank_light.csv\n#BM_Daily_Measurements.csv\n#BM_SWChem.csv\n#BM_NBS_pH.csv\n#BM_NMR_Data_0.04binned_truncated_nowater.csv\n#BM_NMR_sample_info\n#pH probe calibration files : Coral_DNAMethylation_Plasticity/R_Analysis/Data/pH_Calibration_Files/\n#BM_Methylation.csv\n#BM_Buoyant_Weight.csv\n\n\n#############################################################\nsetwd(\"/Users/hputnam/Publications/In_Prep/Primary/Bulk_Methylation/Coral_DNAMethylation_Plasticity/R_Analysis/Data\") #set working directory\n\n\n#------------------------------------------------\n##ACCLIMATION LIGHT AND TEMPERATURE ANALYSIS\n#Data from period that corals were held in tank prior to experimental conditions\n#load tank acclimation light and temp data\nAcclim.data <- read.csv(\"BM_Acclimation.csv\", header=TRUE, sep=\",\", na.strings=\"NA\") #load data with a header, separated by commas, with NA as NA\n\nlight.eq <-Acclim.data$Tank3.Light #Assign light column in dataframe\nlight <-(light.eq+48.339)/23.674 #Apply the cross calibration of the odyssey light to Licor cosine sensor standard 192SA cosine sensor\n\ntemp.eq <-Acclim.data$Tank3.Temp #Assign temperature column in dataframe\ntemp <-(temp.eq+0.4518)/1.0208 #Apply the cross calibration of temperature to standard logger #1\n\nAcc <- data.frame(Acclim.data$Date.Time, light, temp) #combine light and temperature data\n\nmydate <- strptime(Acc$Acclim.data.Date.Time, format=\"%m/%d/%y %H:%M\") #convert date format to characters\nquarterhours <- format(as.POSIXct(mydate) ,format = \"%H:%M\") #set time as every 15 min\nAcc.data <- cbind(Acc, quarterhours) #make a dataframe out of data and new times\nAcc.data #View data\nAcc.light.N <- sum(!is.na(Acc.data$light)) #Count sample size\nAcc.light.N #View data\n\nquarterly.light.mean <- aggregate(light ~ quarterhours, data=Acc.data, mean, na.rm=TRUE) #calculate mean of light for every 15 min interval\nquarterly.light.se <- aggregate(light ~ quarterhours, data=Acc.data, std.error, na.rm=TRUE) #calculate standard error of the mean of light for every 15 min interval\n\nlight.means <- data.frame(quarterly.light.mean, quarterly.light.se$light) #combine mean and standard error results\ncolnames(light.means) <- c(\"Time\", \"mean\", \"se\")  #rename columns to describe contents\n\nFig1 <- ggplot(light.means) + #Plot average diurnal cycle of light data\n  geom_point(aes(x = Time, y = mean), colour=\"black\") + #Plot points using time as the x axis, light as the Y axis and black points\n  geom_errorbar(aes(x=Time, ymax=mean+se, ymin=mean-se), data=light.means) + #set values for standard error bars\n  scale_x_discrete(breaks=c(\"0:00\", \"01:00\", \"02:00\", \"03:00\", \"04:00\", \"05:00\", \"06:00\", \"07:00\", \"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\",\"13:00\", \"14:00\", \"15:00\", \"16:00\", \"17:00\", \"18:00\",\"19:00\", \"20:00\", \"21:00\", \"22:00\", \"23:00\")) + #set discrete breaks on the X axis\n  ggtitle(\"C\") + #Label the graph with the main title\n  xlab(\"Time\") + #Label the X Axis\n  ylab(bquote('Irradiance ('*mu~ 'mol' ~photons ~ m^-2~s^-1*')')) + #Label the Y Axis\n  theme_bw() + #Set the background color\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), #Set the text angle\n        axis.line = element_line(color = 'black'), #Set the axes color\n        panel.border = element_blank(), #Set the border\n        panel.grid.major = element_blank(), #Set the major gridlines\n        panel.grid.minor = element_blank(), #Set the minor gridlines\n        plot.background=element_blank(), #Set the plot background\n        plot.title=element_text(hjust=0)) #Justify the title to the top left\nFig1 #View figure\n\n#------------------------------------------------\n#ACCLIMATION TEMPERATURE ANALYSIS\n#Tank Temperature Data\nquarterly.temp.mean <- aggregate(temp ~ quarterhours, data=Acc.data, mean, na.rm=TRUE) #calculate mean of temperature for every 15 min interval\nquarterly.temp.se <- aggregate(temp ~ quarterhours, data=Acc.data, std.error, na.rm=TRUE) #calculate standard error of the mean of temperature for every 15 min interval\nAcc.temp.N <- sum(!is.na(Acc.data$temp)) #Count sample size\ntemp.means <- data.frame(quarterly.temp.mean, quarterly.temp.se$temp) #combine mean and standard error results\ncolnames(temp.means) <- c(\"Time\", \"mean\", \"se\")  #rename columns to describe contents\n\nFig2 <- ggplot(temp.means) + #Plot average diurnal cycle of temperature data\n  geom_point(aes(x = Time, y = mean), colour=\"black\") + #Plot points using time as the x axis, light as the Y axis and black dots\n  geom_errorbar(aes(x=Time, ymax=mean+se, ymin=mean-se), position=position_dodge(0.9), data=temp.means) + #set values for standard error bars and offset on the X axis for clarity\n  scale_x_discrete(breaks=c(\"0:00\", \"01:00\", \"02:00\", \"03:00\", \"04:00\", \"05:00\", \"06:00\", \"07:00\", \"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\",\"13:00\", \"14:00\", \"15:00\", \"16:00\", \"17:00\", \"18:00\",\"19:00\", \"20:00\", \"21:00\", \"22:00\", \"23:00\")) + #set discrete breaks on the X axis\n  ggtitle(\"B\") + #Label the graph with the main title\n  xlab(\"Time\") + #Label the X Axis\n  ylab(\"Temperature (°C)\") + #Label the Y Axis\n  theme_bw() + #Set the background color\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), #Set the text angle\n        axis.line = element_line(color = 'black'), #Set the axes color\n        panel.border = element_blank(), #Set the border\n        panel.grid.major = element_blank(), #Set the major gridlines\n        panel.grid.minor = element_blank(), #Set the minor gridlines\n        plot.background=element_blank(), #Set the plot background\n        plot.title=element_text(hjust=0)) #Justify the title to the top left\nFig2 #View figure\n\n#------------------------------------------------\n#Field Temperature Data\n#load field collection/acclimation temp data\nField.data <- read.csv(\"BM_Field_Temp.csv\", header=TRUE, sep=\",\", na.strings=\"NA\") #load data with a header, separated by commas, with NA as NA\nmydate2 <- strptime(Field.data$Date.Time, format=\"%m/%d/%y %H:%M\") #convert date format to characters\nquarterhours2 <- format(as.POSIXct(mydate2) ,format = \"%H:%M\") #set time as every 15 min\nField.data <- cbind(Field.data, quarterhours2) #make a dataframe out of data and new times\nField.data #View data\nmin(Field.data$Temperature)\nmax(Field.data$Temperature)\nquarterly.temp.mean2 <- aggregate(Temperature ~ quarterhours2, data=Field.data, mean, na.rm=TRUE) #calculate mean of temperature for every 15 min interval\nquarterly.temp.se2 <- aggregate(Temperature ~ quarterhours2, data=Field.data, std.error, na.rm=TRUE)  #calculate standard error of the mean of temperature for every 15 min interval\nField.temp.N <- sum(!is.na(Field.data$Temperature)) #Count sample size\nfield.temp.means <- data.frame(quarterly.temp.mean2, quarterly.temp.se2$Temperature) #combine mean and standard error results\ncolnames(field.temp.means) <- c(\"Time\", \"mean\", \"se\")  #rename columns to describe contents\n\n#Plot average diurnal cycle of temp data\nFig3 <- ggplot(field.temp.means) + #Plot average diurnal cycle of temperature data\n  geom_point(aes(x = Time, y = mean), colour=\"black\") + #Plot points using time as the x axis, light as the Y axis and black dots\n  geom_errorbar(aes(x=Time, ymax=mean+se, ymin=mean-se), position=position_dodge(0.9), data=field.temp.means) + #set values for standard error bars and offset on the X axis for clarity\n  scale_x_discrete(breaks=c(\"0:00\", \"01:00\", \"02:00\", \"03:00\", \"04:00\", \"05:00\", \"06:00\", \"07:00\", \"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\",\"13:00\", \"14:00\", \"15:00\", \"16:00\", \"17:00\", \"18:00\",\"19:00\", \"20:00\", \"21:00\", \"22:00\", \"23:00\")) + #set discrete breaks on the X axis\n  ggtitle(\"A\") + #Label the graph with the main title\n  xlab(\"Time\") + #Label the X Axis\n  ylab(\"Temperature (°C)\") + #Label the Y Axis\n  theme_bw() + #Set the background color\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), #Set the text angle\n        axis.line = element_line(color = 'black'), #Set the axes color\n        panel.border = element_blank(), #Set the border\n        panel.grid.major = element_blank(), #Set the major gridlines\n        panel.grid.minor = element_blank(), #Set the minor gridlines\n        plot.background=element_blank(), #Set the plot background\n        plot.title=element_text(hjust=0)) #Justify the title to the top left\nFig3 #View figure\n\n#------------------------------------------------\n#TANK EXPERIMENTAL TEMPERATURE ANALYSIS\n#Tank4 = (y4+0.5642)/1.0247 Cross Calibration to temperature standard logger #1\n#Tank5 = (y5+0.2527)/1.0126 Cross Calibration to temperature standard logger #1\n#Tank4=Serial Number 10489734,\tTank5=Serial Number 10489735\t\n\n#LOAD DATA\ntank.data <- read.csv(\"BM_Tank_Temp.csv\", header=TRUE, sep=\",\", na.strings=\"NA\") #load data with a header, separated by commas, with NA as NA\nmydate.tanks <- strptime(tank.data$Date.Time, format=\"%m/%d/%y %H:%M\") #convert date format to characters\n\nTank4 <-(tank.data$Tank4+0.5642)/1.0247 #Standardize temperature data to standard logger #1 Serial Number \nTank5 <-(tank.data$Tank5+0.2527)/1.0126 #Standardize temperature data to standard logger #1 Serial Number \ntank.tempdata <-data.frame(mydate.tanks, Tank4, Tank5) #make a dataframe of temperature and time\ncolnames(tank.tempdata) <- c(\"Date.Time\", \"Tank4\", \"Tank5\")\nTank4.temp.N <- sum(!is.na(tank.tempdata$Tank4)) #Count sample size\nTank5.temp.N <- sum(!is.na(tank.tempdata$Tank5)) #Count sample size\n\nFig4 <- ggplot(tank.tempdata, aes(Date.Time)) + #plot tank temperature data\n  geom_line(aes(y = Tank4, colour=\"Ambient\")) + #plot Temperature data as a line on the Y axis with date as the X axis \n  geom_line(aes(y = Tank5, colour=\"High\")) +\n  scale_colour_manual(\"Treatment\", values = c(\"blue\",\"red\")) +\n  xlab(\"Date\") + #Label the X Axis\n  ylab(\"Temperature °C\") + #Label the Y Axis\n  ggtitle(\"\") + #label the main title\n  theme_bw() + #Set the background color\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), #Set the text angle\n        axis.line = element_line(color = 'black'), #Set the axes color\n        panel.border = element_blank(), #Set the border\n        panel.grid.major = element_blank(), #Set the major gridlines\n        panel.grid.minor = element_blank(), #Set the minor gridlines\n        plot.background =element_blank(), #Set the plot background\n        legend.key = element_blank(), #Set plot legend key\n        plot.title=element_text(hjust=0)) #Justify the title to the top left\nFig4 #View figure\n\ntank.temp <- tank.tempdata[, 2:3] #subset the data to tank number and temperature data\ntank.temp <- melt(tank.temp,  na.rm=TRUE) #rearrange the data in long format removing NA or missing data\ncolnames(tank.temp) <- c(\"Tank.Number\", \"Tank.Temperature\") #rename the data columns\n\nmean.tank.temp <-ddply(tank.temp, .(Tank.Number), summarize, #For each subset of a data frame, apply function then combine results into a data frame.\n                  mean = (mean(Tank.Temperature)),       #take the average of the temp column summarized by Tank number\n                  sem = (sd(Tank.Temperature)/sqrt(length(tank.temp)))) #calculate the SEM as the sd/sqrt of the count or data length\nmean.tank.temp # display mean and sem temp levels\nsem.tank.temp <-transform(mean.tank.temp, lower=mean-sem, upper=mean+sem) # add the upper and lower SEM values to the dataframe\nsem.tank.temp #display mean and sem temp levels with lower and upper values for each tank\n\nFig5 <- ggplot(mean.tank.temp, aes(x = Tank.Number, y = mean)) + # plot mean temp by tank\n  geom_point(data = mean.tank.temp, aes(y = mean), # points represent the mean\n             colour = 'black', size = 5) + # plot black points of size 5\n  geom_errorbar(aes(ymax=upper, ymin=lower), data=sem.tank.temp) + # plot mean and sem together\n  xlab(\"Tanks\") + #Label the X Axis\n  ylab(\"Temperature °C\") + #Label the Y Axis\n  ggtitle(\"\") + #Label the main title\n  theme_bw() + #Set the background color\n  theme(axis.line = element_line(color = 'black'), #Set the axes color\n        panel.border = element_blank(), #Set the border\n        panel.grid.major = element_blank(), #Set the major gridlines\n        panel.grid.minor = element_blank(), #Set the minor gridlines\n        plot.background=element_blank(), #Set the plot background\n        plot.title=element_text(hjust=0)) #Justify the title to the top left\nFig5 #View figure\n\ntanks.mean <- mean(tank.temp$Tank.Temperature) #Calculate the grand average of both tanks\ntanks.mean #View data\ntanks.se <- sd(tank.temp$Tank.Temperature)/sqrt(length(tank.temp$Tank.Temperature)) #Calculate the overal standard error of both tanks\ntanks.se #View data\n\n\n#Plotting diurnal cycles\ntank.time <- format(as.POSIXct(mydate.tanks) ,format = \"%H:%M\") #Format time into only hours and minutes\ntank.temperatures <- cbind(tank.tempdata, tank.time) #create a dataframe \ncolnames(tank.temperatures) <- c(\"Date\", \"Tank4\", \"Tank5\", \"Time\") #Rename columns to describe contents\ntank.temperatures #View Data\n\nquarterly.tank.temp.mean4 <- aggregate(Tank4 ~ Time, data=tank.temperatures, mean, na.rm=TRUE) #calculate mean of temperature for every 15 min interval\nquarterly.tank.temp.se4 <- aggregate(Tank4 ~ Time, data=tank.temperatures, std.error, na.rm=TRUE)  #calculate standard error of the mean of temperature for every 15 min interval\nquarterly.tank.temp.mean5 <- aggregate(Tank5 ~ Time, data=tank.temperatures, mean, na.rm=TRUE) #calculate mean of temperature for every 15 min interval\nquarterly.tank.temp.se5 <- aggregate(Tank5 ~ Time, data=tank.temperatures, std.error, na.rm=TRUE)  #calculate standard error of the mean of temperature for every 15 min interval\ntank.temp.means <- data.frame(quarterly.tank.temp.mean4, quarterly.tank.temp.se4$Tank4, quarterly.tank.temp.mean5$Tank5, quarterly.tank.temp.se5$Tank5) #combine mean and standard error results\ncolnames(tank.temp.means) <- c(\"Time\", \"Tank4.mean\", \"Tank4.se\", \"Tank5.mean\", \"Tank5.se\")  #Rename columns to describe contents\n\nFig6 <- ggplot(tank.temp.means, aes(Time)) + # plot mean temp by tank\n  geom_point(aes(y = Tank4.mean, colour=\"Ambient\")) + #plot points\n  geom_errorbar(aes(x=Time, ymax=Tank4.mean+Tank4.se, ymin=Tank4.mean-Tank4.se), position=position_dodge(0.9), data=tank.temp.means) + #set values for standard error bars and offset on the X axis for clarity\n  geom_point(aes(y = Tank5.mean, colour=\"High\")) + #plot points\n  geom_errorbar(aes(x=Time, ymax=Tank5.mean+Tank5.se, ymin=Tank5.mean-Tank5.se), position=position_dodge(0.9), data=tank.temp.means) + #set values for standard error bars and offset on the X axis for clarity\n  scale_colour_manual(\"Treatment\", values = c(\"blue\",\"red\")) +\n  scale_x_discrete(breaks=c(\"0:00\", \"01:00\", \"02:00\", \"03:00\", \"04:00\", \"05:00\", \"06:00\", \"07:00\", \"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\",\"13:00\", \"14:00\", \"15:00\", \"16:00\", \"17:00\", \"18:00\",\"19:00\", \"20:00\", \"21:00\", \"22:00\", \"23:00\")) + #set discrete breaks on the X axis\n  ggtitle(\"A\") + \n  xlab(\"Time\") + #Label the X Axis\n  ylab(\"Temperature (°C)\") + #Label the Y Axis\n  theme_bw() + #Set the background color\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), #Set the text angle\n        axis.line = element_line(color = 'black'), #Set the axes color\n        panel.border = element_blank(), #Set the border\n        panel.grid.major = element_blank(), #Set the major gridlines\n        panel.grid.minor = element_blank(), #Set the minor gridlines\n        plot.background =element_blank(), #Set the plot background\n        legend.key = element_blank(), #Set plot legend key\n        plot.title=element_text(hjust=0)) #Justify the title to the top left\nFig6 #View figure\n\n#------------------------------------------------\n#TANK EXPERIMENTAL LIGHT ANALYSIS\n\n#load light data\ntank.light.data <- read.csv(\"BM_Tank_light.csv\", header=TRUE, sep=\",\", na.strings=\"NA\") #load data with a header, separated by commas, with NA as NA\nmydate.light <- strptime(tank.light.data$Date.Time, format=\"%m/%d/%y %H:%M\") #convert date format to characters\n\nTank4 <-(tank.light.data$Tank4-63.099)/19.652 #Apply the cross calibration of the odyssey light to Licor cosine sensor standard 192SA cosine sensor\nTank5 <-(tank.light.data$Tank5-49.729)/19.54 #Apply the cross calibration of the odyssey light to Licor cosine sensor standard 192SA cosine sensor\n\ntank.light.data <-data.frame(mydate.light, Tank4, Tank5) #make a dataframe of light and time\ncolnames(tank.light.data) <- c(\"Date.Time\", \"Tank4\", \"Tank5\") #Rename columns to describe contents\n\nTank4.light.N <- sum(!is.na(tank.light.data$Tank4)) #Count sample size\nTank5.light.N <- sum(!is.na(tank.light.data$Tank5)) #Count sample size\n\nFig7 <- ggplot(tank.light.data, aes(Date.Time)) + #plot tank light data\n  geom_line(aes(y = Tank4, colour=\"Ambient\")) + #plot light data as a line on the Y axis with date as the X axis \n  geom_line(aes(y = Tank5, colour=\"High\")) + #plot light data as a line on the Y axis with date as the X axis for additional treatment\n  scale_colour_manual(\"Treatment\", values = c(\"blue\",\"red\")) + #color the treatment groups differently\n  xlab(\"Date\") + #Label the X Axis\n  ylab(bquote('Irradiance ('*mu~ 'mol' ~photons ~ m^-2~s^-1*')')) + #Label the Y Axis\n  ggtitle(\"BM Tank Light\") + #Label the main title\n  theme_bw() + #Set the background color\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), #Set the text angle\n        axis.line = element_line(color = 'black'), #Set the axes color\n        panel.border = element_blank(), #Set the border\n        panel.grid.major = element_blank(), #Set the major gridlines\n        panel.grid.minor = element_blank(), #Set the minor gridlines\n        plot.background =element_blank(), #Set the plot background\n        legend.key = element_blank()) #Set plot legend key\nFig7 #View figure\n\ntank.light <- tank.light.data[, 2:3] #subset the data to tank number and light data\ntank.light  <- melt(tank.light ,  na.rm=TRUE) #rearrange the data in long format removing NA or missing data\ncolnames(tank.light ) <- c(\"Tank.Number\", \"Tank.Light\") #rename the data columns\n\nmean.tank.light <-ddply(tank.light, .(Tank.Number), summarize, #For each subset of a data frame, apply function then combine results into a data frame.\n                       mean = (mean(Tank.Light)),       #take the average of the light column summarized by Tank number\n                       sem = (sd(Tank.Light)/sqrt(length(tank.light)))) #calculate the SEM as the sd/sqrt of the count or data length\nmean.tank.light # display mean and sem temp levels\nmean.tank.light<-transform(mean.tank.light, lower=mean-sem, upper=mean+sem) # add the upper and lower SEM values to the dataframe\nmean.tank.light #display mean and sem of light levels with lower and upper values for each tank\n\nFig8 <- ggplot(mean.tank.light, aes(x = Tank.Number, y = mean)) + # plot mean light by tank\n  geom_point(data = mean.tank.light, aes(y = mean), # points represent the mean\n             colour = 'black', size = 5) + # plot black points of size 5\n  geom_errorbar(aes(ymax=upper, ymin=lower), data=mean.tank.light) + # plot mean and sem together\n  xlab(\"Tanks\") + #Label the X Axis\n  ylab(bquote('Irradiance ('*mu~ 'mol' ~photons ~ m^-2~s^-1*')')) + #Label the Y Axis\n  ggtitle(\"BM Diurnal Tank Light\") + #label the main title\n  theme_bw() + #Set the background color\n  theme(axis.line = element_line(color = 'black'), #Set the axes color\n        panel.border = element_blank(), #Set the border\n        panel.grid.major = element_blank(), #Set the major gridlines\n        panel.grid.minor = element_blank(), #Set the minor gridlines\n        plot.background=element_blank()) #Set the plot background\nFig8 #View figure\n\ntanks.light.mean <- mean(tank.light$Tank.Light) #Calculate the grand average of light data\ntanks.light.mean #View data\ntanks.light.se <- sd(tank.light$Tank.Light)/(sqrt(length(tank.temp$Tank.Light))) #Calculate the overall standard error of the light data\ntanks.light.se #View data\n\n#Plotting diurnal cycles\ntank.time <- format(as.POSIXct(mydate.light) ,format = \"%H:%M\") #set time to hours and minutes\ntank.lights <- cbind(tank.light.data, tank.time) #Combine time and light data\ncolnames(tank.lights) <- c(\"Date\", \"Tank4\", \"Tank5\", \"Time\") #Rename columns to describe contents\ntank.lights #View data\n\nquarterly.tank.light.mean4 <- aggregate(Tank4 ~ Time, data=tank.lights, mean, na.rm=TRUE) #calculate mean of light for every 15 min interval\nquarterly.tank.light.se4 <- aggregate(Tank4 ~ Time, data=tank.lights, std.error, na.rm=TRUE)  #calculate standard error of the mean of light for every 15 min interval\nquarterly.tank.light.mean5 <- aggregate(Tank5 ~ Time, data=tank.lights, mean, na.rm=TRUE) #calculate mean of light for every 15 min interval\nquarterly.tank.light.se5 <- aggregate(Tank5 ~ Time, data=tank.lights, std.error, na.rm=TRUE)  #calculate standard error of the mean of light for every 15 min interval\ntank.light.means <- data.frame(quarterly.tank.light.mean4, quarterly.tank.light.se4$Tank4, quarterly.tank.light.mean5$Tank5, quarterly.tank.light.se5$Tank5) #combine mean and standard error results\ncolnames(tank.light.means) <- c(\"Time\", \"Tank4.mean\", \"Tank4.se\", \"Tank5.mean\", \"Tank5.se\")  #Rename columns to describe contents\n\nFig9 <- ggplot(tank.light.means, aes(Time)) + # plot mean light by tank\n  geom_point(aes(y = Tank4.mean, colour=\"Ambient\")) + #plot points\n  geom_errorbar(aes(x=Time, ymax=Tank4.mean+Tank4.se, ymin=Tank4.mean-Tank4.se), position=position_dodge(0.9), data=tank.light.means) + #set values for standard error bars and offset on the X axis for clarity\n  geom_point(aes(y = Tank5.mean, colour=\"High\")) + #plot points\n  geom_errorbar(aes(x=Time, ymax=Tank5.mean+Tank5.se, ymin=Tank5.mean-Tank5.se), position=position_dodge(0.9), data=tank.light.means) + #set values for standard error bars and offset on the X axis for clarity\n  scale_colour_manual(\"Treatment\", values = c(\"blue\",\"red\")) +\n  scale_x_discrete(breaks=c(\"0:00\", \"01:00\", \"02:00\", \"03:00\", \"04:00\", \"05:00\", \"06:00\", \"07:00\", \"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\",\"13:00\", \"14:00\", \"15:00\", \"16:00\", \"17:00\", \"18:00\",\"19:00\", \"20:00\", \"21:00\", \"22:00\", \"23:00\")) + #set discrete breaks on the X axis\n  ggtitle(\"B\") + #Label the graph\n  xlab(\"Time\") + #Label the X Axis\n  ylab(bquote('Irradiance ('*mu~ 'mol' ~photons ~ m^-2~s^-1*')')) + #Label the Y Axis\n  theme_bw() + #Set the background color\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), #Set the text angle\n        axis.line = element_line(color = 'black'), #Set the axes color\n        panel.border = element_blank(), #Set the border\n        panel.grid.major = element_blank(), #Set the major gridlines\n        panel.grid.minor = element_blank(), #Set the minor gridlines\n        plot.background =element_blank(), #Set the plot background\n        legend.key = element_blank(), #Set plot legend key\n        plot.title=element_text(hjust=0)) #Justify the title to the top left\nFig9 #View figure\n\n#------------------------------------------------\n#SEAWATER CHEMISTRY ANALYSIS FOR CONTINUOUS MEASUREMENTS\n\n#read in probe measurements of pH, temperature, and salinity from tanks\ndaily <- read.csv(\"BM_Daily_Measurements.csv\", header=TRUE, sep=\",\", na.strings=\"NA\") #load data with a header, separated by commas, with NA as NA\n\nsal <- aggregate(Salinity ~ Treatment, data=daily, mean, na.rm = TRUE) #Calculate average salinity from the tank YSI probe measurements\nsal #View data\n#if salinity is the same in both treatments, take grand average\n#if the salinity is different by treatment, use individual salinity values manually assigned\nsal <- mean(daily$Salinity) #Assign the salinity from the calculated mean value\nsal #View data\n\n# read in total alkalinity, temperature, and salinity\nSW.chem <- read.csv(\"BM_SWChem.csv\", header=TRUE, sep=\",\", na.strings=\"NA\") #load data with a header, separated by commas, with NA as NA\n\nTA.mean <- aggregate(Corrected.TA ~ Treatment, data=SW.chem, mean, na.rm = TRUE) #calculate the average of total alkalinity in each tank\nTA.mean #View data\nTA.se <- aggregate(Corrected.TA ~ Treatment, data=SW.chem, std.error, na.rm = TRUE) #calculate the standard error of total alkalinity in each tank\nTA.se #View data\nTAs <- cbind(TA.mean, TA.se$Corrected.TA) #merge the mean and standard error of total alkalinity\ncolnames(TAs) <- c(\"Treatment\", \"mean\", \"se\") #Rename columns to describe contents\nTAs #View data\n\n# read in NBS pH data from Aquacontrollers frequency 15min\npHs <- read.csv(\"BM_NBS_pH.csv\", header=TRUE, sep=\",\", na.strings=\"NA\") #load data with a header, separated by commas, with NA as NA\n\nmydate.pHs <- strptime(pHs$Date.Time, format=\"%m/%d/%y %H:%M\") #Identify date format\npHs <- data.frame(mydate.pHs, pHs$High.NBS, pHs$Ambient.NBS) #combine dataframe of date and pH\ncolnames(pHs) <- c(\"Date.Time\", \"High.NBS\", \"Ambient.NBS\") #Rename columns to describe contents\npH.data <- merge(pHs, tank.tempdata, by=\"Date.Time\") #merge data sets by time and date\n\n#Convert pH from NBS to total scale for high tank \npH <- pH.data$High.NBS # pH data on NBS scale logged every 15 minutes\nTemp.High <- pH.data$Tank5+273.15 # Temperature from Hobo loggers every 15 minutes that match pH measurement frequency converted to Kelvin\nS <- sal # salinity measured daily with YSI meter calibrated to conductivity standard at 25°C\n\nTS <- (0.14/96.062)*(S/1.80655) #concentration of SO4-2 in mol/kg-SW \n##Morris, A. W., and Riley, J. P., Deep-Sea Research 13:699-705, 1966: this is .02824.*Sali./35. = .0008067.*Sali\n\nTF <- (0.000067/18.998)*(S/1.80655) #concentration of fluoride in mol/kg-SW \n##Riley, J. P., Deep-Sea Research 12:219-220, 1965\n\nfH <- 1.2948 - 0.002036*Temp.High + (0.0004607 -  0.000001475*Temp.High)*(S^2) # the activity coefficient of the H+ ion, which is valid for the temperatures of 20-40°C\n#Takahashi et al, Chapter 3 in GEOSECS Pacific Expedition, v. 3, 1982 (p. 80)\n\nIonS <- (19.924*S)/(1000 - 1.005*S) # the ionic strength of Hydrogen Fluoride \n##This is from the DOE handbook, Chapter 5, p. 13/22, eq. 7.2.4 and Zeebe Wolfgladrow Appendix A p260\n\nlnKSO4 <- -4276.1/Temp.High + 141.328 - 23.093*log(Temp.High) + \n  (-13856/Temp.High + 324.57 - 47.986*log(Temp.High))*sqrt(IonS) +    \n  (35474/Temp.High - 771.54 + 114.723*log(Temp.High))*IonS +\n  (-2698/Temp.High)*sqrt(IonS)*IonS + (1776/Temp.High)*IonS^2 \nKSO4 <- exp(lnKSO4)*(1-0.001005*S) #this is on the free pH scale in mol/kg-SW \n#This is from the DOE handbook 1994 ORNL/CDIAC-74\n\nlnKF <- 1590.2/Temp.High - 12.641 + 1.525*sqrt(IonS)\nKF <- exp(lnKF)*(1-0.001005*S) #the dissociation constant of HF, this is on the free pH scale in mol/kg-H2O\n#Dickson, A. G. and Riley, J. P., Marine Chemistry 7:89-99, 1979\n\n#Conversion Functions\nSWStoTOT.high  <- (1 + TS/KSO4)/(1 + TS/KSO4 + TF/KF) #pH scale conversion factor\nNBStoTOT.high <- pH-(log(SWStoTOT.high)/log(0.1) + log(fH)/log(0.1))  #conversion for NBS to total                                  \n\npH.High.Out <- data.frame(pH.data$Date.Time, pH.data$Tank5, pH.data$High.NBS, NBStoTOT.high) #create dataframe of total pH, Temperature, and time\ncolnames(pH.High.Out) <- c(\"Date.Time\", \"High.Temp\", \"pH.High.NBS\", \"pH.High.TOTAL\") #Rename columns to describe contents\n\n#Convert pH from NBS to total scale for ambient tank \npH<- pH.data$Ambient.NBS # pH data on NBS scale logged every 15 minutes\nTemp.Amb <- pH.data$Tank4+273.15 # Temperature from Hobo loggers every 15 minutes that match pH measurement frequency\n\nTS <- (0.14/96.062)*(S/1.80655) #concentration of SO4-2 in mol/kg-SW \n##Morris, A. W., and Riley, J. P., Deep-Sea Research 13:699-705, 1966: this is .02824.*Sali./35. = .0008067.*Sali\n\nTF <- (0.000067/18.998)*(S/1.80655) #concentration of fluoride in mol/kg-SW \n##Riley, J. P., Deep-Sea Research 12:219-220, 1965\n\nfH <- 1.2948 - 0.002036*Temp.Amb + (0.0004607 -  0.000001475*Temp.Amb)*(S^2) # the activity coefficient of the H+ ion, which is valid for the temperatures of 20-40°C\n#Takahashi et al, Chapter 3 in GEOSECS Pacific Expedition, v. 3, 1982 (p. 80)\n\nIonS <- (19.924*S)/(1000 - 1.005*S) # the ionic strength of Hydrogen Fluoride \n##This is from the DOE handbook, Chapter 5, p. 13/22, eq. 7.2.4 and Zeebe Wolfgladrow Appendix A p260\n\nlnKSO4 <- -4276.1/Temp.Amb + 141.328 - 23.093*log(Temp.Amb) + \n  (-13856/Temp.Amb + 324.57 - 47.986*log(Temp.Amb))*sqrt(IonS) +    \n  (35474/Temp.Amb - 771.54 + 114.723*log(Temp.Amb))*IonS +\n  (-2698/Temp.Amb)*sqrt(IonS)*IonS + (1776/Temp.Amb)*IonS^2 \nKSO4 <- exp(lnKSO4)*(1-0.001005*S) #this is on the free pH scale in mol/kg-SW \n#This is from the DOE handbook 1994 ORNL/CDIAC-74\n\nlnKF <- 1590.2/Temp.Amb - 12.641 + 1.525*sqrt(IonS)\nKF <- exp(lnKF)*(1-0.001005*S) #the dissociation constant of HF, this is on the free pH scale in mol/kg-H2O\n#Dickson, A. G. and Riley, J. P., Marine Chemistry 7:89-99, 1979\n\n#Conversion Functions\nSWStoTOT.amb  <- (1 + TS/KSO4)/(1 + TS/KSO4 + TF/KF) #pH scale conversion factor\nNBStoTOT.amb <- pH-(log(SWStoTOT.amb)/log(0.1) + log(fH)/log(0.1))  #conversion for NBS to total                                  \n\npH.Amb.Out <- data.frame(pH.data$Date.Time, pH.data$Tank4, pH.data$Ambient.NBS, NBStoTOT.amb) #create dataframe of pH and time\ncolnames(pH.Amb.Out) <- c(\"Date.Time\", \"Amb.Temp\", \"pH.Amb.NBS\", \"pH.Amb.TOTAL\") #Rename columns to describe contents\n\npH.TOT <- cbind(pH.High.Out, pH.Amb.Out$Amb.Temp,  pH.Amb.Out$pH.Amb.NBS,\tpH.Amb.Out$pH.Amb.TOTAL) #create dataframe of total pH and time\ncolnames(pH.TOT) <- c(\"Date.Time\",  \"High.Temp\",\t\"pH.High.NBS\",\t\"pH.High.TOTAL\",\t\"Amb.Temp\",\t\"pH.Amb.NBS\",\t\"pH.Amb.TOTAL\")\n\n#Plot total pH for both treatments for duration of experiment\nFig10 <- ggplot(pH.TOT) + #plot pH total scale\n  geom_line(aes(x = Date.Time, y = pH.High.TOTAL, col=\"High\")) + #plot as a line\n  geom_line(aes(x = Date.Time, y = pH.Amb.TOTAL, col=\"Ambient\")) + #plot as a line\n  xlab(\"Date\") + #Label the X Axis\n  ylab(\"pH (Total Scale)\") + #Label the Y Axis\n  ggtitle(\"All Tanks Total pH\") + #Label the graph title\n  theme_bw() + #Set the background color\n  theme(axis.line = element_line(color = 'black'), #Set the axes color\n        panel.border = element_blank(), #Set the border\n        panel.grid.major = element_blank(), #Set the major gridlines\n        panel.grid.minor = element_blank(), #Set the minor gridlines\n        plot.background =element_blank(), #Set the plot background\n        legend.key = element_blank()) #Set plot legend key\nFig10 #View figure\n\npH.time <- format(as.POSIXct(pH.TOT$Date.Time) ,format = \"%H:%M\") #Identify time in hours and minutes\npH.TOT <- cbind(pH.TOT, pH.time) #Combine total pH and time\ncolnames(pH.TOT) <- c(\"Date.Time\",  \"High.Temp\",  \"pH.High.NBS\",\t\"pH.High.TOTAL\",\t\"Amb.Temp\",\t\"pH.Amb.NBS\",\t\"pH.Amb.TOTAL\", \"Time\") #Rename columns to describe contents\n\nquarterly.tank.pH.amb.mean <- aggregate(pH.Amb.TOTAL ~ Time, data=pH.TOT, mean, na.rm=TRUE) #calculate mean of pH for every 15 min interval\nquarterly.tank.pH.amb.se <- aggregate(pH.Amb.TOTAL ~ Time, data=pH.TOT, std.error, na.rm=TRUE)  #calculate standard error of the mean of pH for every 15 min interval\nquarterly.tank.pH.high.mean <- aggregate(pH.High.TOTAL ~ Time, data=pH.TOT, mean, na.rm=TRUE) #calculate mean of pH for every 15 min interval\nquarterly.tank.pH.high.se <- aggregate(pH.High.TOTAL ~ Time, data=pH.TOT, std.error, na.rm=TRUE)  #calculate standard error of the mean of pH for every 15 min interval\ntank.pH.means <- data.frame(quarterly.tank.pH.amb.mean, quarterly.tank.pH.amb.se$pH.Amb.TOTAL, quarterly.tank.pH.high.mean$pH.High.TOTAL, quarterly.tank.pH.high.se$pH.High.TOTAL) #combine mean and standard error results\ncolnames(tank.pH.means) <- c(\"Time\", \"pH.Amb.TOTAL.mean\", \"pH.Amb.TOTAL.se\", \"pH.High.TOTAL.mean\", \"pH.High.TOTAL.se\")  #Rename columns to describe contents\n\nFig11 <- ggplot(tank.pH.means, aes(Time)) + # plot mean pH by tank\n  geom_point(aes(x =Time, y = pH.Amb.TOTAL.mean, colour=\"Ambient\")) + #plot points\n  geom_errorbar(aes(x=Time, ymax=pH.Amb.TOTAL.mean+pH.Amb.TOTAL.se, ymin=pH.Amb.TOTAL.mean-pH.Amb.TOTAL.se), position=position_dodge(0.9), data=tank.pH.means) + #set values for standard error bars and offset on the X axis for clarity\n  geom_point(aes(x = Time, y = pH.High.TOTAL.mean, colour=\"High\")) + #plot points\n  geom_errorbar(aes(x=Time, ymax=pH.High.TOTAL.mean+pH.High.TOTAL.se, ymin=pH.High.TOTAL.mean-pH.High.TOTAL.se), position=position_dodge(0.9), data=tank.pH.means) + #set values for standard error bars and offset on the X axis for clarity\n  scale_colour_manual(\"Treatment\", values = c(\"blue\",\"red\")) +\n  scale_x_discrete(breaks=c(\"0:00\", \"01:00\", \"02:00\", \"03:00\", \"04:00\", \"05:00\", \"06:00\", \"07:00\", \"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\",\"13:00\", \"14:00\", \"15:00\", \"16:00\", \"17:00\", \"18:00\",\"19:00\", \"20:00\", \"21:00\", \"22:00\", \"23:00\")) + #set discrete breaks on the X axis\n  ggtitle(\"A\") + #Label graph\n  xlab(\"Time\") + #Label the X Axis\n  ylab(\"pH (Total Scale)\") + #Label the Y Axis\n  theme_bw() + #Set the background color\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), #Set the text angle\n        axis.line = element_line(color = 'black'), #Set the axes color\n        panel.border = element_blank(), #Set the border\n        panel.grid.major = element_blank(), #Set the major gridlines\n        panel.grid.minor = element_blank(), #Set the minor gridlines\n        plot.background =element_blank(), #Set the plot background\n        legend.key = element_blank(), #Set plot legend key\n        plot.title=element_text(hjust=0)) #Justify the title to the top left\nFig11 #View figure\n\n#Generate dataframe and set parameters for seacarb calculations\nFor.seacarb <- pH.TOT[,c(1,2,4,5,7,8)] #create data frame of temp and total pH\nFor.seacarb$Salinity <- sal #set salinity from average of tanks\nFor.seacarb$TA.Amb <- TAs[1,2] #set TA from average of ambient tanks calculated above\nFor.seacarb$TA.High <- TAs[2,2] #set TA from average of high tanks calculated above\ncolnames(For.seacarb) <- c(\"Date.Time\", \"Temp.High\", \"pH.High.TOTAL\",\t\"Temp.Amb\", \"pH.Amb.TOTAL\", \"Time\", \"Salinity\",\t\"TA.Amb\",\t\"TA.High\") #Rename columns to describe contents\nFor.seacarb <- na.omit(For.seacarb) #omit missing values\n\n#Calculate CO2 parameters using seacarb\ncarbo.high <- carb(flag=8, var1=For.seacarb$pH.High.TOTAL, var2=For.seacarb$TA.High/1000000, S= For.seacarb$Salinity, T=For.seacarb$Temp.High, P=0, Pt=0, Sit=0, pHscale=\"T\", kf=\"pf\", k1k2=\"l\", ks=\"d\") #calculate seawater chemistry parameters using seacarb\ncarbo.amb <- carb(flag=8, var1=For.seacarb$pH.Amb.TOTAL, var2=For.seacarb$TA.Amb/1000000, S= For.seacarb$Salinity, T=For.seacarb$Temp.Amb, P=0, Pt=0, Sit=0, pHscale=\"T\", kf=\"pf\", k1k2=\"l\", ks=\"d\") #calculate seawater chemistry parameters using seacarb\n\npCO2 <- data.frame(For.seacarb$Date.Time, For.seacarb$Time, carbo.amb$pCO2, carbo.high$pCO2) #make dataframe of CO2 output\ncolnames(pCO2) <- c(\"Date.Time\", \"Time\", \"pCO2.Amb\", \"pCO2.High\") #Rename columns to describe contents\n\nquarterly.tank.pCO2.amb.mean <- aggregate(pCO2.Amb ~ Time, data=pCO2, mean, na.rm=TRUE) #calculate mean of pCO2 for every 15 min interval\nquarterly.tank.pCO2.amb.se <- aggregate(pCO2.Amb ~ Time, data=pCO2, std.error, na.rm=TRUE)  #calculate standard error of the mean of pCO2 for every 15 min interval\nquarterly.tank.pCO2.high.mean <- aggregate(pCO2.High ~ Time, data=pCO2, mean, na.rm=TRUE) #calculate mean of pCO2 for every 15 min interval\nquarterly.tank.pCO2.high.se <- aggregate(pCO2.High ~ Time, data=pCO2, std.error, na.rm=TRUE)  #calculate standard error of the mean of pCO2 for every 15 min interval\ntank.pCO2.means <- data.frame(quarterly.tank.pCO2.amb.mean, quarterly.tank.pCO2.amb.se$pCO2.Amb, quarterly.tank.pCO2.high.mean$pCO2.High, quarterly.tank.pCO2.high.se$pCO2.High) #combine mean and standard error results\ncolnames(tank.pCO2.means) <- c(\"Time\", \"Amb.mean\", \"Amb.se\", \"High.mean\", \"High.se\") #Rename columns to describe contents\n\n#plotting averages of total pH every 15 min for a 1 day cycle from all data\nFig12 <- ggplot(tank.pCO2.means) + #plot pCO2\n  geom_point(aes(x = Time, y = Amb.mean, colour=\"Ambient\")) + #plot as line\n  geom_errorbar(aes(x=Time, ymax=Amb.mean+Amb.se, ymin=Amb.mean-Amb.se), position=position_dodge(0.9), data=tank.pCO2.means) + #plot error bars\n  geom_point(aes(x = Time, y = High.mean, colour=\"High\")) + #plot as line\n  geom_errorbar(aes(x=Time, ymax=High.mean+High.se, ymin=High.mean-High.se), position=position_dodge(0.9), data=tank.pCO2.means) + #plot error bars\n  scale_colour_manual(\"Treatment\", values = c(\"blue\",\"red\")) + #Set colors for treatments\n  scale_x_discrete(breaks=c(\"0:00\", \"01:00\", \"02:00\", \"03:00\", \"04:00\", \"05:00\", \"06:00\", \"07:00\", \"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\",\"13:00\", \"14:00\", \"15:00\", \"16:00\", \"17:00\", \"18:00\",\"19:00\", \"20:00\", \"21:00\", \"22:00\", \"23:00\")) + #set discrete breaks on the X axis\n  ggtitle(\"B\") + #Label graph\n  xlab(\"Time\") + #Label the X Axis\n  ylab(expression(paste('p',CO[2], ' (µatm)', sep=''))) + #Label the Y Axis\n  theme_bw() + #Set the background color\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), #Set the text angle\n        axis.line = element_line(color = 'black'), #Set the axes color\n        panel.border = element_blank(), #Set the border\n        panel.grid.major = element_blank(), #Set the major gridlines\n        panel.grid.minor = element_blank(), #Set the minor gridlines\n        plot.background =element_blank(), #Set the plot background\n        legend.key = element_blank(), #Set plot legend key\n        plot.title=element_text(hjust=0)) #Justify the title to the top left\nFig12 #View figure\n\n#------------------------------------------------\n#SEAWATER CHEMISTRY ANALYSIS FOR DISCRETE MEASUREMENTS\n#Seawater chemistry table from simultaneous TA, pH, temperature and salinity measurements\n\n#Need to load data to make conversion equations for pH from mV to total scale using tris standard\n\npath <-(\"/Users/hputnam/Publications/In_Prep/Primary/Bulk_Methylation/Coral_DNA_Methylation/R_Analysis/Data/pH_Calibration_Files/\")\n\n#list all the file names in the folder to get only get the csv files\nfile.names<-list.files(path = path, pattern = \"csv$\")\n\npH.cals <- data.frame(matrix(NA, nrow=length(file.names), ncol=3, dimnames=list(file.names,c(\"Date\", \"Intercept\", \"Slope\")))) #generate a 3 column dataframe with specific column names\n\nfor(i in 1:length(file.names)) { # for every file in list start at the first and run this following function\n  Calib.Data <-read.table(file.path(path,file.names[i]), header=TRUE, sep=\",\", na.string=\"NA\", as.is=TRUE) #reads in the data files\n  model <-lm(mVTris ~ TTris, data=Calib.Data) #runs a linear regression of mV as a function of temperature\n  coe <- coef(model) #extracts the coeffecients\n  pH.cals[i,2:3] <- coe #inserts them in the dataframe\n  pH.cals[i,1] <- substr(file.names[i],1,8) #stores the file name in the Date column\n}\n\ncolnames(pH.cals) <- c(\"Calib.Date\",  \"Intercept\",\t\"Slope\")\n\n#merge with Seawater chemistry file\nSW.chem <- merge(pH.cals, SW.chem, by=\"Calib.Date\")\n\n#constants for use in pH calculation \nR <- 8.31447215 #gas constant in J mol-1 K-1 \nF <-96485.339924 #Faraday constant in coulombs mol-1\n\nmvTris <- SW.chem$Temperature*SW.chem$Slope+SW.chem$Intercept #calculate the mV of the tris standard using the temperature mv relationships in the measured standard curves \nSTris<-34.5 #salinity of the Tris\nphTris<- (11911.08-18.2499*STris-0.039336*STris^2)*(1/(SW.chem$Temperature+273.15))-366.27059+ 0.53993607*STris+0.00016329*STris^2+(64.52243-0.084041*STris)*log(SW.chem$Temperature+273.15)-0.11149858*(SW.chem$Temperature+273.15) #calculate the pH of the tris (Dickson A. G., Sabine C. L. and Christian J. R., SOP 6a)\nSW.chem$pH.Total<-phTris+(mvTris/1000-SW.chem$pH.MV/1000)/(R*(SW.chem$Temperature+273.15)*log(10)/F) #calculate the pH on the total scale (Dickson A. G., Sabine C. L. and Christian J. R., SOP 6a)\n\n#Calculate CO2 parameters using seacarb\ncarb.ouptput <- carb(flag=8, var1=SW.chem$pH.Total, var2=SW.chem$Corrected.TA/1000000, S= SW.chem$Salinity, T=SW.chem$Temperature, P=0, Pt=0, Sit=0, pHscale=\"T\", kf=\"pf\", k1k2=\"l\", ks=\"d\") #calculate seawater chemistry parameters using seacarb\n\ncarb.ouptput$ALK <- carb.ouptput$ALK*1000000 #convert to µmol kg-1\ncarb.ouptput$CO2 <- carb.ouptput$CO2*1000000 #convert to µmol kg-1\ncarb.ouptput$HCO3 <- carb.ouptput$HCO3*1000000 #convert to µmol kg-1\ncarb.ouptput$CO3 <- carb.ouptput$CO3*1000000 #convert to µmol kg-1\ncarb.ouptput$DIC <- carb.ouptput$DIC*1000000 #convert to µmol kg-1\n\ncarb.ouptput <- cbind(SW.chem$Measure.Date,  SW.chem$Tank,\tSW.chem$Treatment, carb.ouptput) #combine the sample information with the seacarb output\ncolnames(carb.ouptput) <- c(\"Date\",  \"Tank\",  \"Treatment\",\t\"flag\",\t\"Salinity\",\t\"Temperature\",\t\"Pressure\",\t\"pH\",\t\"CO2\",\t\"pCO2\",\t\"fCO2\",\t\"HCO3\",\t\"CO3\",\t\"DIC\", \"TA\",\t\"Aragonite.Sat\", \t\"Calcite.Sat\") #Rename columns to describe contents\n\ncarbo.melted <- melt(carb.ouptput) #reshape the dataframe to more easily summarize all output parameters\nmean.carb.output <-ddply(carbo.melted, .(Treatment, variable), summarize, #For each subset of a data frame, apply function then combine results into a data frame.\n                       mean = (mean(value)),       #take the average of the parameters (variables) summarized by treatments\n                       sem = (sd(value)/sqrt(length(carbo.melted)))) #calculate the SEM as the sd/sqrt of the count or data length\nmean.carb.output # display mean and sem \nmean.carb.output <- mean.carb.output[with(mean.carb.output, order(variable)), ] #order the data by the variables\nmean.carb.output <- mean.carb.output[-c(1:4,9,10,29,30), ] #remove non-numeric parameters extra\n\nwrite.table (mean.carb.output, \"Seawater_chemistry_table_Output.csv\", sep=\",\", row.names = FALSE)\n\n#------------------------------------------------\n#METABOLOMIC ANALYSIS\n\n#load data after truncation from 0.5-10 and removal of water peak (4.73959- 4.93955 ppm)\nmetabo.data <- read.csv(\"BM_NMR_Data_0.04binned_truncated_nowater.csv\", header=TRUE, sep=\",\", na.strings=\"NA\") #load data with a header, separated by commas, with NA as NA\n\n#loadsample info\nmetabo.info <- read.csv(\"BM_NMR_sample_info.csv\", header=TRUE, sep=\",\", na.strings=\"NA\") #load data with a header, separated by commas, with NA as NA\n\n#DATA NORMALIZATION AND SCALING\nNMRData.norm<-sweep(as.matrix(metabo.data[,grep('X', colnames(metabo.data))]), 1,metabo.info$Extract.Weight.g, '/') #normalize by extractweight\nNMRData.norm[NMRData.norm<0]<-0 #Assign negative values to 0 value\n\n#Scale the data\nNMRData.scale <- scaling(NMRData.norm, type=\"pareto\") #scale the data using pareto scaling to give more weight to medium features without inflating the baseline noise, the calculate is done by dividing each variable by the square root of its SD\n\n#Mean center the data\nNMRData.scale <- scale(NMRData.scale, center=TRUE, scale=FALSE) #scale the data about the mean. This calculation is done by subtracting the grand mean from each individual data point\n\n#calculate similarity matrix of euclidean distance\ndist.euc <- vegdist(NMRData.scale, method = \"euclidean\", binary=FALSE, diag=FALSE, upper=FALSE, na.rm = FALSE) #calculates euclidean distance on the transformed data matrix\n\n#Run PCA and look at summary to identify outliers\npca.res <- prcomp(dist.euc, retx=TRUE)\nsummary(pca.res)\nbiplot(pca.res)\nY <- metabo.info$Treatment #SELECTS FOR GROUPING\nordiellipse(pca.res, group=rep(c(1), c(length(Y))), conf=0.99, kind='sd', draw='lines')  \n\n#remove outliers identified outside 99%cl\ncleaned.all.data <- NMRData.norm[-c(3,4,7,11,15,16,19,41,42,44,48,51,53),] #remove outliers identified in PCA outside 99%cl\ncleaned.all.info <- metabo.info[-c(3,4,7,11,15,16,19,41,42,44,48,51,53),] #remove sample info of outliers identified in PCA outside 99%cl\n\ncleaned.data <- NMRData.scale[-c(3,4,7,11,15,16,19,41,42,44,48,51,53),] #remove outliers identified in PCA outside 99%cl\ncleaned.info <- metabo.info[-c(3,4,7,11,15,16,19,41,42,44,48,51,53),] #remove sample info of outliers identified in PCA outside 99%cl\n\nmetabo.Species <- cleaned.info$Species #identify Species\nmetabo.Treatment <- cleaned.info$Treatment #Identify Treatments\n\nsample.counts <- aggregate(cleaned.info[\"Coral.ID\"], by=cleaned.info[c(\"Species\",\"Treatment\")], FUN=length) #calculate sample size \nsample.counts #View data\n\n#REcalculate similarity matrix of euclidean distance of only cleaned data\ndist.euc <- vegdist(cleaned.data, method = \"euclidean\", binary=FALSE, diag=FALSE, upper=FALSE, na.rm = FALSE) #calculates euclidean distance on the transformed data matrix\n\n#Run PCA and look at summary to identify outliers\npca.res <- prcomp(dist.euc, retx=TRUE) #run PCA analysis\nsummary(pca.res) #summarize PCA output\nbiplot(pca.res) #plot PCs and loadings\nTreats <- cleaned.info$Treatment #identifies the grouping information\nordiellipse(pca.res,group=rep(c(1), c(length(Treats))), conf=0.99, kind='sd', draw='lines')  \n\nscores <- as.data.frame(pca.res$x) # extract all PCs\n\nPCA.plot <- ggplot(scores, aes(x = PC1, y = PC2, shape=metabo.Species, col=metabo.Treatment)) + # plot of PC1 and PC2\n  geom_point(size=4) + # use points + \n  scale_shape_manual(values=c(16,17, 18, 3)) + #create your own scale and values for scale\n  theme(panel.background = element_rect(fill='white', colour='black')) + #removes gray background\n  theme(panel.grid.major = element_line(colour=\"white\"), panel.grid.minor = element_line(colour=\"white\")) + #Set the panel gridlines\n  theme(legend.key = element_rect(fill='white')) + #Set plot legend key\n  theme(panel.border = element_rect(fill=NA, size = 1, colour = \"black\")) #Set the border\nPCA.plot\n\n#OPLS Analysis of All Data\nALL.X<-as.matrix(cleaned.data) #Identify Data\nclass(ALL.X)<-'numeric' #changes class data to numeric \nALL.Y<-as.matrix(as.numeric(as.factor(as.vector(cleaned.info$Species)))) #Select the grouping for model testing\nALL.ulabels <- unique(as.vector(cleaned.info$Species)) #Identify the labels for the groupings\nset.seed(10) #sets the value on the uniform random-number generator so that the analysis can be reproduced every time\nALL.resultsALL<-n.group.opls(ALL.X,ALL.Y, num_permutations=100, CV= 10, nIterations=100, min_num_OPLS_fact=1) #run the OPLS DA model (Anderson)\nALL.Q2<-ALL.resultsALL$Q2 #GIVES Q2 VALUE\nALL.pval<-ALL.resultsALL$helper.results$pvalue #GIVES P-VALUE FOR MODEL \nALL.modelALL <- ALL.resultsALL$helper.results$model\nALL.OPLSResults<-data.frame(model=c('Species'), Q2=c(ALL.Q2), pval=c(ALL.pval))\nALL.OPLSResults\n\n#visualize\nt.opls <- as.numeric(as.vector(ALL.modelALL$t)) #assign numeric t values from OPLS results\nt.ortho.opls <- as.numeric(as.vector(ALL.modelALL$t_ortho)) #assign numeric t-orthogonal values from OPLS results\nAll.metabo.data <- data.frame(metabo.Species, t.opls, t.ortho.opls) #create a dataframe\ncolnames(All.metabo.data) <- c(\"Species\", \"t\", \"t.ortho\") #Rename columns\n\nFig13 <- ggplot(All.metabo.data, aes(t, t.ortho)) + \n  geom_point(aes(x=t, y=t.ortho, colour=Species, shape=Species)) +\n  scale_colour_manual(\"Species\", values = c(\"black\",\"gray\")) + #Set colors for Species\n  scale_shape_manual(values = c(17,19)) + #Set shape for Species\n  xlim(-1600, 1600) +\n  ylim(-2500, 2500) +\n  ggtitle(\"A All Species\") + #Label graph\n  xlab(\"t\") + #Label the X Axis\n  ylab(\"t-Orthogonal\") + #Label the Y Axis\n  theme_bw() + #Set the background color\n  theme(axis.line = element_line(color = 'black'), #Set the axes color\n        axis.title=element_text(size=14,face=\"bold\"), #Set axis format\n        panel.border = element_blank(), #Set the border\n        panel.grid.major = element_blank(), #Set the major gridlines\n        panel.grid.minor = element_blank(), #Set the minor gridlines\n        plot.background =element_blank(), #Set the plot background\n        legend.key = element_blank(), #Set plot legend key\n        legend.position=\"top\", #Set position of legend in graphic\n        plot.title=element_text(hjust=0, face=\"bold\")) #Justify the title to the top left and use Bold italics font\nFig13  #View figure\n\n\n#MONTIPORA OUTLIER CHECK\nMC.data <-subset(cleaned.all.data, cleaned.all.info$Species=='Montipora capitata') #Select only the Montipora data from the dataset from which outliers have been removed.\nMC.info<-subset(cleaned.all.info, cleaned.all.info$Species=='Montipora capitata') #Select only the Montipora info\nwhich(colSums(MC.data) ==0) #check to see if any bins (columns) are present in the whole analysis, but not in Montipora only\nMC.data <- MC.data [, colSums(MC.data  != 0) > 0]\nwhich(colSums(MC.data) ==0)\n\n#assign treatment from info\nMC.Treatment <- MC.info$Treatment\n\n#Scale the data\nMC.NMRData.scale <-scaling(MC.data, type=\"pareto\")\n\n#Mean center the data\nMC.NMRData.scale <- scale(MC.NMRData.scale, center=TRUE, scale=FALSE)\n\n#calculate similarity matrix of euclidean distance\nMC.dist.euc <- vegdist(MC.NMRData.scale, method = \"euclidean\", binary=FALSE, diag=FALSE, upper=FALSE, na.rm = TRUE) #calculates euclidean distance on the transformed data matrix\nMC.pca.res <- prcomp(MC.dist.euc, retx=TRUE)\nsummary(MC.pca.res)\n\n#check for outliers\nbiplot(MC.pca.res) #plot PC1 and PC2\nordiellipse(MC.pca.res,group=rep(c(1), c(length(MC.Treatment))), conf=0.99, kind='sd', draw='lines')  #plot 99% confidence interval ellipse\n\n#remove outliers and assess sample size\ncleaned.MC.data <- MC.NMRData.scale[-c(5,37,22,9,13),] #remove outliers identified in PCA\ncleaned.MC.info <- MC.info[-c(5,37,22,9,13),] #remove sample info of outliers identified in PCA\ncleaned.MC.Treat <- cleaned.MC.info$Treatment #Set the treatment information for the filtered data\nMC.counts <- aggregate(cleaned.MC.info[\"Coral.ID\"], by=cleaned.MC.info[c(\"Species\",\"Treatment\")], FUN=length) #check the sample size for each Treatment\nMC.counts #view the sample size for each Treatment\n\n#calculate similarity matrix of euclidean distance\nMC.dist.euc <- vegdist(cleaned.MC.data, method = \"euclidean\", binary=FALSE, diag=FALSE, upper=FALSE, na.rm = TRUE) #calculates euclidean distance on the transformed data matrix\nMC.pca.res <- prcomp(MC.dist.euc, retx=TRUE)\nsummary(MC.pca.res)\n\n#Double check for outliers\nbiplot(MC.pca.res)\nordiellipse(MC.pca.res,group=rep(c(1), c(length(cleaned.MC.Treat))), conf=0.99, kind='sd', draw='lines')  \n\n# extract all PCs\nMC.scores <- as.data.frame(MC.pca.res$x)\nMC.PCA.plot <- ggplot(MC.scores, aes(x = PC1, y = PC2, shape=cleaned.MC.Treat , col=cleaned.MC.Treat )) +\n  geom_point(size=4) + # use points + \n  scale_shape_manual(values=c(16,16)) + #create your own scale and values for scale\n  theme(panel.background = element_rect(fill='white', colour='black')) + #removes gray background\n  theme(panel.grid.major = element_line(colour=\"white\"), panel.grid.minor = element_line(colour=\"white\")) + #Set the panel gridlines\n  theme(legend.key = element_rect(fill='white')) + #Set plot legend key\n  theme(panel.border = element_rect(fill=NA, size = 1, colour = \"black\")) + #Set the border\n  ggtitle(\"M. capitata\")\nMC.PCA.plot\n\n#Montipora OPLS Data\nMC.X<-as.matrix(cleaned.MC.data) #SELECT DATA -- USER INPUT\nclass(MC.X)<-'numeric' #changes class data to numeric \nMC.Y<-as.matrix(as.numeric(as.factor(as.vector(cleaned.MC.info$Treatment)))) #SELECT GROUPING -- USER INPUT BY CHANGING COLUMN USED\nMC.ulabels <- unique(as.vector(cleaned.MC.info$Treatment)) #PICK LABELS \nset.seed(10) #sets the value on the uniform random-number generator so that the analysis can be reproduced every time\nMC.resultsALL<-n.group.opls(MC.X,MC.Y, num_permutations=100, CV= 10, nIterations=100, min_num_OPLS_fact=1) #RUNS MODEL\nMC.Q2<-MC.resultsALL$Q2 #GIVES Q2 VALUE\nMC.pval<-MC.resultsALL$helper.results$pvalue #GIVES P-VALUE FOR MODEL \nMC.modelALL <- MC.resultsALL$helper.results$model #lists results\nMC.OPLSResults<-data.frame(model=c('M. capitata'), Q2=c(MC.Q2), pval=c(MC.pval)) #lists Q2 and p\nMC.OPLSResults\n\n#visualize\nMC.t.opls <- as.numeric(as.vector(MC.modelALL$t)) #assign numeric t values from OPLS results\nMC.t.ortho.opls <- as.numeric(as.vector(MC.modelALL$t_ortho)) #assign numeric t-orthogonal values from OPLS results\nMC.metabo.data <- data.frame(cleaned.MC.Treat, MC.t.opls, MC.t.ortho.opls) #create a dataframe\ncolnames(MC.metabo.data) <- c(\"Treatment\", \"t\", \"t.ortho\") #Rename columns\n\nFig14 <- ggplot(MC.metabo.data, aes(t, t.ortho)) + \n  geom_point(aes(x=t, y=t.ortho, colour=Treatment)) +\n  scale_colour_manual(\"Treatment\", values = c(\"blue\",\"red\")) + #Set colors for Species\n  xlim(-1600, 1600) +\n  ylim(-2500, 2500) +\n  ggtitle(\"B  Montipora capitata\") + #Label graph\n  xlab(\"t\") + #Label the X Axis\n  ylab(\"t-Orthogonal\") + #Label the Y Axis\n  theme_bw() + #Set the background color\n  theme(axis.line = element_line(color = 'black'), #Set the axes color\n        axis.title=element_text(size=14,face=\"bold\"), #Set axis format\n        panel.border = element_blank(), #Set the border\n        panel.grid.major = element_blank(), #Set the major gridlines\n        panel.grid.minor = element_blank(), #Set the minor gridlines\n        plot.background =element_blank(), #Set the plot background\n        legend.key = element_blank(), #Set plot legend key\n        legend.position=\"top\", #Set position of legend in graphic\n        plot.title=element_text(hjust=0, face=\"bold.italic\")) #Justify the title to the top left and use Bold italics font\nFig14  #View figure\n\n#POCILLIPORA OUTLIER CHECK\nPD.data <-subset(cleaned.all.data, cleaned.all.info$Species=='Pocillopora damicornis') #Select only the Pocillopora data from the dataset from which outliers have been removed.\nPD.info<-subset(cleaned.all.info, cleaned.all.info$Species=='Pocillopora damicornis') #Select only the Pocillopora info\nwhich(colSums(PD.data) ==0) #check to see if any bins (columns) are present in the whole analysis, but not in Pocillopora only\nPD.data <- PD.data [, colSums(PD.data  != 0) > 0] #remove the coloumns that have zeros\nwhich(colSums(PD.data) ==0) #check again for any zero columns\n\n#assign treatment from info\nPD.Treatment <- PD.info$Treatment\n\n#Scale the data\nPD.NMRData.scale <- scaling(PD.data, type=\"pareto\")\n\n#Mean center the data\nPD.NMRData.scale <- scale(PD.NMRData.scale, center=TRUE, scale=FALSE)\n\n#calculate similarity matrix of euclidean distance\nPD.dist.euc <- vegdist(PD.NMRData.scale, method = \"euclidean\", binary=FALSE, diag=FALSE, upper=FALSE, na.rm = FALSE) #calculates euclidean distance on the transformed data matrix\nPD.pca.res <- prcomp(PD.dist.euc, retx=TRUE)\nsummary(PD.pca.res)\n\nbiplot(PD.pca.res)\nordiellipse(PD.pca.res,group=rep(c(1), c(length(PD.Treatment))), conf=0.99, kind='sd', draw='lines')  \n\n#remove outliers and assess sample size\ncleaned.PD.data <- PD.NMRData.scale[-c(17),] #remove outliers identified in PCA\ncleaned.PD.info <- PD.info[-c(17),] #remove sample info of outliers identified in PCA\ncleaned.PD.Treat <- cleaned.PD.info$Treatment #Set the treatment information for the filtered data\nPD.counts <- aggregate(cleaned.PD.info[\"Coral.ID\"], by=cleaned.PD.info[c(\"Species\",\"Treatment\")], FUN=length) #check the sample size for each Treatment\nPD.counts #view the sample size for each Treatment\n\n#calculate similarity matrix of euclidean distance\nPD.dist.euc <- vegdist(cleaned.PD.data, method = \"euclidean\", binary=FALSE, diag=FALSE, upper=FALSE, na.rm = TRUE) #calculates euclidean distance on the transformed data matrix\nPD.pca.res <- prcomp(PD.dist.euc, retx=TRUE)\nsummary(PD.pca.res)\n\n#Double check for outliers\nbiplot(PD.pca.res)\nordiellipse(PD.pca.res,group=rep(c(1), c(length(cleaned.PD.Treat))), conf=0.99, kind='sd', draw='lines')  \n\n# extract all PCs\nPD.scores <- as.data.frame(PD.pca.res$x)\nPD.PCA.plot <- ggplot(PD.scores, aes(x = PC1, y = PC2, shape=cleaned.PD.Treat, col=cleaned.PD.Treat)) +\n  geom_point(size=4) + # use points + \n  scale_shape_manual(values=c(17,17)) + #create your own scale and values for scale\n  theme(panel.background = element_rect(fill='white', colour='black')) + #removes gray background\n  theme(panel.grid.major = element_line(colour=\"white\"), panel.grid.minor = element_line(colour=\"white\")) + #Set the panel gridlines\n  theme(legend.key = element_rect(fill='white')) + #Set plot legend key\n  theme(panel.border = element_rect(fill=NA, size = 1, colour = \"black\")) + #Set the border\n  ggtitle(\"P. damicornis\")\nPD.PCA.plot\n\nPD.X<-as.matrix(cleaned.PD.data) #SELECT DATA -- USER INPUT\nclass(PD.X)<-'numeric' #changes class data to numeric \nPD.Y<-as.matrix(as.numeric(as.factor(as.vector(cleaned.PD.info$Treatment)))) #SELECT GROUPING -- USER INPUT BY CHANGING COLUMN USED\nPD.ulabels <- unique(as.vector(cleaned.PD.info$Treatment)) #PICK LABELS \nset.seed(10)\nPD.resultsALL<-n.group.opls(PD.X,PD.Y, num_permutations=100, CV= 10, nIterations=100, min_num_OPLS_fact=1) #RUNS MODEL\nPD.Q2<-PD.resultsALL$Q2 #GIVES Q2 VALUE\nPD.pval<-PD.resultsALL$helper.results$pvalue #GIVES P-VALUE FOR MODEL \nPD.modelALL <- PD.resultsALL$helper.results$model\nPD.OPLSResults<-data.frame(model=c('P. damicornis'), Q2=c(PD.Q2), pval=c(PD.pval))\nPD.OPLSResults #View Results\n\n#visualize\nPD.t.opls <- as.numeric(as.vector(PD.modelALL$t)) #assign numeric t values from OPLS results\nPD.t.ortho.opls <- as.numeric(as.vector(PD.modelALL$t_ortho)) #assign numeric t-orthogonal values from OPLS results\nPD.metabo.data <- data.frame(cleaned.PD.Treat, PD.t.opls, PD.t.ortho.opls) #create a dataframe\ncolnames(PD.metabo.data) <- c(\"Treatment\", \"t\", \"t.ortho\") #Rename columns\n\nFig15 <- ggplot(PD.metabo.data, aes(t, t.ortho)) + \n  geom_point(aes(x=t, y=t.ortho, colour=Treatment)) +\n  scale_colour_manual(\"Treatment\", values = c(\"blue\",\"red\")) + #Set colors for Species\n  xlim(-1600, 1600) +\n  ylim(-2500, 2500) +\n  ggtitle(\"C  Pocillopora damicornis\") + #Label graph\n  xlab(\"t\") + #Label the X Axis\n  ylab(\"t-Orthogonal\") + #Label the Y Axis\n  theme_bw() + #Set the background color\n  theme(axis.line = element_line(color = 'black'), #Set the axes color\n        axis.title=element_text(size=14,face=\"bold\"), #Set axis format\n        panel.border = element_blank(), #Set the border\n        panel.grid.major = element_blank(), #Set the major gridlines\n        panel.grid.minor = element_blank(), #Set the minor gridlines\n        plot.background =element_blank(), #Set the plot background\n        legend.key = element_blank(), #Set plot legend key\n        legend.position=\"top\", #Set position of legend in graphic\n        plot.title=element_text(hjust=0, face=\"bold.italic\")) #Justify the title to the top left and use Bold italics font\nFig15  #View figure\n\n#------------------------------------------------\n#Growth Analysis\n\n#load weight data\nweight <- read.csv(\"BM_Buoyant_Weight.csv\", header=TRUE, sep=\",\", na.strings=\"NA\") #load data with a header, separated by commas, with NA as NA\n\nPD.Arag <- 2.78 #g cm-3, set aragonite density for Pocillopora from literature\nMC.Arag <- 2.03 #g cm-3, set aragonite density for Montipora from literature\n#Pocillopora Arag = 2.78 g cm-3 Spencer-Davies 1989 Mar Bio 101:389-395, Al-Sofyani and Floos 2013 Oecologia 55:917-935 \n#Montipora Arag = 2.03 g cm-3 average from table 2 in Anthony 2003 Functional Ecology 17:246-259\n\n#TimeInitial date=20140501\nTemp0 <- 23.92 #Temperature of the measurement\nRefDry0 <- 39.110 #weight of solid glass dry reference in air\nRefSW0 <- 21.129 #weight of solid glass reference in seawater\nRefFW0 <- 21.582 #weight of solid glass reference in freshwater\nDenFW0 <- ((-0.000005*Temp0*Temp0)+(0.000007*Temp0)+1.0001) #g cm-3 Calculates density of the freshwater as a function of temperature\nDenRef0 <- ((RefDry0*DenFW0)/(RefDry0-RefFW0)) #g cm-3 Equation 4 from Spencer Davies 1989 calculates the density of the reference weight\nDenSW0 <- ((DenRef0*(RefDry0-RefSW0))/(RefDry0))  #g cm-3 Equation 3 from Spencer Davies 1989 using the density of the calcualted reference weight\n\n#TimeFinal date=20140612\nTemp5 <- 26.24 #Temperature of the measurement\nRefDry5 <- 39.110 #weight of solid glass dry reference in air\nRefSW5 <- 21.128 #weight of solid glass reference in seawater\nRefFW5 <- 21.572 #weight of solid glass reference in freshwater\nDenFW5 <- ((-0.000005*Temp5*Temp5)+(0.000007*Temp5)+1.0001) #g cm-3 Calculates density of the freshwater as a function of temperature\nDenRef5 <- ((RefDry5*DenFW5)/(RefDry5-RefFW5)) #g cm-3 Equation 4 from Spencer Davies 1989 calculates the density of the reference weight\nDenSW5 <- ((DenRef5*(RefDry5-RefSW5))/(RefDry5))  #g cm-3 Equation 3 from Spencer Davies 1989 using the density of the calcualted reference weight\n\ndays <- 43\n\n#Montipora Dry Weight\n#Subset weights by species\nMC.weight <-subset(weight, weight$Species=='Montipora capitata') \nPD.weight <-subset(weight, weight$Species=='Pocillopora damicornis') \n\nMC.dryweight.initial <- ((MC.weight$Initial_01May)/(1-(DenSW0/MC.Arag))) #Calculates the dry weight in grams using Equation 1 from Spencer Davies 1989 calculates the density of the reference weight\nMC.dryweight.final <- ((MC.weight$Initial_12June)/(1-(DenSW5/MC.Arag))) #Calculates the dry weight in grams using Equation 1 from Spencer Davies 1989 calculates the density of the reference weight\n\nPD.dryweight.initial <- ((PD.weight$Initial_01May)/(1-(DenSW0/PD.Arag))) #Calculates the dry weight in grams using Equation 1 from Spencer Davies 1989 calculates the density of the reference weight\nPD.dryweight.final <- ((PD.weight$Initial_12June)/(1-(DenSW5/PD.Arag))) #Calculates the dry weight in grams using Equation 1 from Spencer Davies 1989 calculates the density of the reference weight\n\nMC.growth.rate <- ((MC.dryweight.final-MC.dryweight.initial)/MC.dryweight.initial)*100/days #calculates growth in % per day (grams changed/grams initial/day)\nPD.growth.rate <- ((PD.dryweight.final-PD.dryweight.initial)/PD.dryweight.initial)*100/days #calculates growth in % per day (grams changed/grams initial/day)\n\n\nMC.growth <- data.frame(MC.weight,MC.growth.rate)\ncolnames(MC.growth) <- c(\"Species\",\t\"Coral.ID\",\t\"Treatment\",\t\"Initial.weight\",\t\"Final.weight\",\t\"Growth.Rate\")\n\nPD.growth <- data.frame(PD.weight,PD.growth.rate)\ncolnames(PD.growth) <- c(\"Species\",  \"Coral.ID\",\t\"Treatment\",\t\"Initial.weight\",\t\"Final.weight\",\t\"Growth.Rate\")\n\ngrowth.rate <-rbind(MC.growth,PD.growth)\n\ngrowth.counts <- aggregate(growth.rate[\"Growth.Rate\"], by=growth.rate[c(\"Species\",\"Treatment\")], FUN=length)\ngrowth.means <- aggregate(Growth.Rate ~ Species + Treatment, data=growth.rate, mean, na.rm = TRUE)\ngrowth.se <- aggregate(Growth.Rate ~ Species + Treatment, data=growth.rate, std.error, na.rm = TRUE)\ngrowth.means <- cbind(growth.means, growth.se$Growth.Rate) \ncolnames(growth.means) <- c(\"Species\", \"Treatment\", \"Growth.mean\", \"Growth.se\")\ngrowth.means[, \"TS\"] <- c(\"MC Amb\", \"PD Amb\", \"MC High\", \"PD High\")\ngrowth.means\n\nFig16 <- ggplot(growth.means, aes(x=Species, y=Growth.mean, fill=Treatment)) + \n  geom_bar() +\n  geom_bar(position=position_dodge(), stat=\"identity\",\n           colour=\"black\", # Use black outlines,\n           size=.3, # set line weight\n           show_guide=FALSE) + #remove slash from legend\n  scale_fill_manual(values=c(\"blue\", \"red\")) +  #Set bar color\n  geom_errorbar(aes(ymin=Growth.mean-Growth.se, ymax=Growth.mean+Growth.se),\n                size=.3,    # set line weight\n                width=.2,   # set error bar width\n                position=position_dodge(.9)) + # offset the lines on the x axis so they match the bars and don't overlap\n  xlab(\"Species\") + #Label the X Axis\n  ylab(\"Growth (% d-1)\") + #Label the Y Axis\n  theme_bw() + #Set the background color\n  theme(axis.line = element_line(color = 'black'), #Set the axes color\n        panel.border = element_blank(), #Set the border\n        panel.grid.major = element_blank(), #Set the major gridlines\n        panel.grid.minor = element_blank(), #Set the minor gridlines\n        plot.background =element_blank(), #Set the plot background\n        legend.key = element_blank()) #Set plot legend key\nFig16 #View figure\n\n\n###Testing ANOVA Assumptions\n###Homogeneity of variance\n#get unstandardized predicted and residual values\ngrowth.results <-aov(log10(Growth.Rate) ~ Treatment + Species + Treatment*Species, data=growth.rate)\ngrowth.stats <- anova(growth.results)\nunstandardizedPredicted <- predict(growth.results)\nunstandardizedResiduals <- resid(growth.results)\n\n#get standardized values and plot to determine normality\nstandardizedPredicted <- (unstandardizedPredicted - mean(unstandardizedPredicted)) / sd(unstandardizedPredicted)\nstandardizedResiduals <- (unstandardizedResiduals - mean(unstandardizedResiduals)) / sd(unstandardizedResiduals)\n#create standardized residuals plot\nplot(standardizedPredicted, standardizedResiduals, main = \"Standardized Residuals Plot\", xlab = \"Standardized Predicted Values\", ylab = \"Standardized Residuals\")\n#add horizontal line\nabline(0,0)\nleveneTest(log10(Growth.Rate) ~Treatment * Species, data=growth.rate)\n\n###Data are normally distributed\nresults.stdres <- rstandard(growth.results)\nqqnorm(results.stdres) # normal quantile plot\nqqline(results.stdres) # adding a qline of comparison\nshapiro.test(results.stdres) #runs a normality test using shapiro-wilk test on the standardized residuals\n\ngrowth.HSD <- TukeyHSD(growth.results, ordered = FALSE, conf.level = 0.95)\ngrowth.HSD\n\n#calculate backtransformed means and SE\ngrowth.rate$rate.trans <- log10(growth.rate$Growth.Rate)\nsp.growth.trans.avg <- aggregate(rate.trans ~ Species, data=growth.rate, mean, na.rm = TRUE) #calculate the averages by Species \nsp.growthbacktrans.avg <- 10^(sp.growth.trans.avg$rate.trans) #backtransform the average\n\ngrowth.trans.avg <- aggregate(rate.trans  ~ Species + Treatment, data=growth.rate, mean, na.rm = TRUE) #calculate the averages by Species and Treatment\ngrowth.trans.se <- aggregate(rate.trans  ~ Species + Treatment, data=growth.rate, std.error, na.rm = TRUE) #calculate the standard errors by Species and Treatment\ngrowth.trans.std <- aggregate(rate.trans  ~ Species + Treatment, data=growth.rate, sd, na.rm = TRUE) #calculate the standard deviation by Species and Treatment\ngrowth.trans <- growth.trans.avg #generate dataframe of averages\ncolnames(growth.trans) <- c(\"Species\", \"Treatment\", \"avg\")\ngrowth.trans$Upper <- growth.trans$avg+growth.trans.se$rate.trans\ngrowth.trans$Lower <- growth.trans$avg-growth.trans.se$rate.trans\nback.trans.growth <- growth.trans\nback.trans.growth$avg <- 10^(growth.trans$avg)\nback.trans.growth$Upper <- 10^(growth.trans$Upper)\nback.trans.growth$Lower <- 10^(growth.trans$Lower)\nback.trans.growth\n\n#Plot backtransformed means and SE\nFig17 <- ggplot(data=back.trans.growth, aes(x=factor(Species), y=(avg), fill=Treatment)) + #plot methylation data averages\n  geom_bar()+\n  geom_bar(stat=\"identity\", position=position_dodge(), #use values and offset position so bars don't overlap\n           colour=\"black\", # set line color,\n           size=.3, #set line weight\n           show_guide=FALSE) + #remove slash from legend\n  scale_fill_manual(values=c(\"blue\", \"red\")) + #set fill color for bars\n  geom_errorbar(aes(ymin=Lower, ymax=Upper), #plot standard errors\n                width=.2,                    # set width of the error bars\n                position=position_dodge(.9)) + #offset position so bars don't overlap\n  ggtitle(\"A\") + #set plot title\n  xlab(\"Species\") + #Label the X Axis\n  ylab(\"Growth (% d-1)\") + #Label the Y Axis\n  theme_bw() + #Set the background color\n  theme(axis.line = element_line(color = 'black'), #Set the axes color\n        panel.border = element_blank(), #Set the border\n        panel.grid.major = element_blank(), #Set the major gridlines\n        panel.grid.minor = element_blank(), #Set the minor gridlines\n        plot.background =element_blank(), #Set the plot background\n        legend.key = element_blank(), #Set plot legend key\n        plot.title=element_text(hjust=0)) #Justify the title to the top left\nFig17 #View figure\n\n#------------------------------------------------\n#DNA METHYLATION ANALYSIS\n\n#load DNA Methylation data\ndata <- read.csv(\"BM_Methylation.csv\", header=TRUE, sep=\",\", na.strings=\"NA\") #load data with a header, separated by commas, with NA as NA\ndata <- na.omit(data) #omit data rows that include NA\ncounts <- aggregate(data[\"Methylation\"], by=data[c(\"Species\",\"Treatment\")], FUN=length) #count the sample sizes\navg <- aggregate(Methylation ~ Species + Treatment, data=data, mean, na.rm = TRUE) #calculate the averages by Species and Treatment\nse <- aggregate(Methylation ~ Species + Treatment, data=data, std.error, na.rm = TRUE) #calculate the standard errors by Species and Treatment\nmethyl <- cbind(avg, se$Methylation) #generate dataframe of averages and standard errors\ncolnames(methyl) <- c(\"Species\", \"Treatment\", \"avg\", \"se\" ) #rename columns of dataframe\n\nFig18 <- ggplot(data=methyl, aes(x=factor(Species), y=(avg), fill=Treatment)) + #plot methylation data averages\n  geom_bar()+\n  geom_bar(stat=\"identity\", position=position_dodge(), #use values and offset position so bars don't overlap\n           colour=\"black\", # set line color,\n           size=.3, #set line weight\n           show_guide=FALSE) + #remove slash from legend\n  scale_fill_manual(values=c(\"blue\", \"red\")) + #set fill color for bars\n  geom_errorbar(aes(ymin=avg-se, ymax=avg+se), #plot standard errors\n                width=.2,                    # set width of the error bars\n                position=position_dodge(.9)) + #offset position so bars don't overlap\n  ggtitle(\"B\") + #set plot title\n  xlab(\"Species\") + #Label the X Axis\n  ylab(\"% DNA Methylation\")+ #Label the Y Axis\n  theme_bw() + #Set the background color\n  theme(axis.line = element_line(color = 'black'), #Set the axes color\n        panel.border = element_blank(), #Set the border\n        panel.grid.major = element_blank(), #Set the major gridlines\n        panel.grid.minor = element_blank(), #Set the minor gridlines\n        plot.background =element_blank(), #Set the plot background\n        legend.key = element_blank(), #Set plot legend key\n        plot.title=element_text(hjust=0)) #Justify the title to the top left\nFig18 #View figure\n\n###Testing ANOVA Assumptions\nmethylation.results <- aov((Methylation^0.25) ~Treatment * Species, data=data)\nmethylation.stats <- anova(methylation.results)\n\n###Testing ANOVA Assumptions\n###Homogeneity of variance\n#get unstandardized predicted and residual values\nunstandardizedPredicted <- predict(methylation.results)\nunstandardizedResiduals <- resid(methylation.results)\n\n#get standardized values and plot to determine homogeneity\nstandardizedPredicted <- (unstandardizedPredicted - mean(unstandardizedPredicted)) / sd(unstandardizedPredicted)\nstandardizedResiduals <- (unstandardizedResiduals - mean(unstandardizedResiduals)) / sd(unstandardizedResiduals)\n#create standardized residuals plot\nplot(standardizedPredicted, standardizedResiduals, main = \"Standardized Residuals Plot\", xlab = \"Standardized Predicted Values\", ylab = \"Standardized Residuals\")\n#add horizontal line\nabline(0,0)\nleveneTest((Methylation^0.33) ~Treatment * Species, data=data)\n\n###Data are normally distributed\nresults.stdres <- rstandard(methylation.results)\nqqnorm(results.stdres) # normal quantile plot\nqqline(results.stdres) # adding a qline of comparison\nshapiro.test(results.stdres) #runs a normality test using shapiro-wilk test on the standardized residuals\n\nmethylation.HSD <- TukeyHSD(methylation.results, ordered = FALSE, conf.level = 0.95) #calculate pairwise differences between groups using Tukey's HSD Test\nmethylation.HSD #View results\n\nMCPDavg <- aggregate(Methylation ~ Species, data=data, mean, na.rm = TRUE) #Calculate methylation average for each species\nMCPDavg #View results\n\n#calculate backtransformed means and SE\ndata$Methylation.trans <- (data$Methylation)^0.25\nsp.trans.avg <- aggregate(Methylation.trans ~ Species, data=data, mean, na.rm = TRUE) #calculate the averages by Species \nsp.backtrans.avg <- (sp.trans.avg$Methylation.trans)^4 #backtransform the average\n\ntrans.avg <- aggregate(Methylation.trans ~ Species + Treatment, data=data, mean, na.rm = TRUE) #calculate the averages by Species and Treatment\ntrans.se <- aggregate(Methylation.trans ~ Species + Treatment, data=data, std.error, na.rm = TRUE) #calculate the standard errors by Species and Treatment\ntrans.std <- aggregate(Methylation.trans ~ Species + Treatment, data=data, sd, na.rm = TRUE) #calculate the standard deviation by Species and Treatment\ntrans.methyl <- trans.avg #generate dataframe of averages\ncolnames(trans.methyl) <- c(\"Species\", \"Treatment\", \"avg\")\ntrans.methyl$Upper <- trans.methyl$avg+trans.se$Methylation.trans\ntrans.methyl$Lower <- trans.methyl$avg-trans.se$Methylation.trans\nback.trans.methyl <- trans.methyl\nback.trans.methyl$avg <- (trans.methyl$avg)^4\nback.trans.methyl$Upper <- (trans.methyl$Upper)^4\nback.trans.methyl$Lower <- (trans.methyl$Lower)^4\nback.trans.methyl\n\n#Plot backtransformed means and SE\nFig19 <- ggplot(data=back.trans.methyl, aes(x=factor(Species), y=(avg), fill=Treatment)) + #plot methylation data averages\n  geom_bar()+\n  geom_bar(stat=\"identity\", position=position_dodge(), #use values and offset position so bars don't overlap\n           colour=\"black\", # set line color,\n           size=.3, #set line weight\n           show_guide=FALSE) + #remove slash from legend\n  scale_fill_manual(values=c(\"blue\", \"red\")) + #set fill color for bars\n  geom_errorbar(aes(ymin=Lower, ymax=Upper), #plot standard errors\n                width=.2,                    # set width of the error bars\n                position=position_dodge(.9)) + #offset position so bars don't overlap\n  ggtitle(\"B\") + #set plot title\n  xlab(\"Species\") + #Label the X Axis\n  ylab(\"% DNA Methylation\")+ #Label the Y Axis\n  theme_bw() + #Set the background color\n  theme(axis.line = element_line(color = 'black'), #Set the axes color\n        panel.border = element_blank(), #Set the border\n        panel.grid.major = element_blank(), #Set the major gridlines\n        panel.grid.minor = element_blank(), #Set the minor gridlines\n        plot.background =element_blank(), #Set the plot background\n        legend.key = element_blank(), #Set plot legend key\n        plot.title=element_text(hjust=0)) #Justify the title to the top left\nFig19 #View figure\n\n\n#------------------------------------------------\n#CAPTURE ALL STATISTICAL OUTPUT TO A FILE\n\ncapture.output(MC.OPLSResults, PD.OPLSResults, ALL.OPLSResults, growth.results, growth.stats, growth.HSD, methylation.results, methylation.stats, methylation.HSD, file=\"Bulk_Methylation_Statistical_Results.txt\")\n\nFigure.S1 <- arrangeGrob(Fig3, Fig2, Fig1, ncol=3)\nggsave(file=\"FigureS1_Manuscript.pdf\", Figure.S1, width = 11, height = 4, units = c(\"in\"))\n\nFigure.S2 <- arrangeGrob(Fig6, Fig9, ncol=2)\nggsave(file=\"FigureS2_Manuscript.pdf\", Figure.S2, width = 11, height = 4, units = c(\"in\"))\n\nFigure.1 <- arrangeGrob(Fig11, Fig12, ncol=2)\nggsave(file=\"Figure1_Manuscript.pdf\", Figure.1, width = 11, height = 4, units = c(\"in\"))\n\nFigure.2 <- arrangeGrob(Fig13, Fig14, Fig15, ncol=1)\nggsave(file=\"Figure2_Manuscript.pdf\", Figure.2, width = 5, height = 11, units = c(\"in\"))\n\nFigure.3 <- arrangeGrob(Fig17, Fig19, ncol=2)\nggsave(file=\"Figure3_Manuscript.pdf\", Figure.3, width = 11, height = 4, units = c(\"in\"))\n\n\n",
    "created" : 1445916312504.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "823018260",
    "id" : "3D9C377D",
    "lastKnownWriteTime" : 1445916247,
    "path" : "~/Publications/In_Prep/Primary/Bulk_Methylation/Coral_DNAMethylation_Plasticity/R_Analysis/Scripts/Coral_DNA_Methylation.R",
    "project_path" : "R_Analysis/Scripts/Coral_DNA_Methylation.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}
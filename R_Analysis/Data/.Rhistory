RefFW5 <- 21.572 #weight of solid glass reference in freshwater
DenFW5 <- ((-0.000005*Temp5*Temp5)+(0.000007*Temp5)+1.0001) #g cm-3 Calculates density of the freshwater as a function of temperature
DenRef5 <- ((RefDry5*DenFW5)/(RefDry5-RefFW5)) #g cm-3 Equation 4 from Spencer Davies 1989 calculates the density of the reference weight
DenSW5 <- ((DenRef5*(RefDry5-RefSW5))/(RefDry5))  #g cm-3 Equation 3 from Spencer Davies 1989 using the density of the calcualted reference weight
days <- 43
#Montipora Dry Weight
#Subset weights by species
MC.weight <-subset(weight, weight$Species=='Montipora capitata')
PD.weight <-subset(weight, weight$Species=='Pocillopora damicornis')
MC.dryweight.initial <- ((MC.weight$Initial_01May)/(1-(DenSW0/MC.Arag))) #Calculates the dry weight in grams using Equation 1 from Spencer Davies 1989 calculates the density of the reference weight
MC.dryweight.final <- ((MC.weight$Initial_12June)/(1-(DenSW5/MC.Arag))) #Calculates the dry weight in grams using Equation 1 from Spencer Davies 1989 calculates the density of the reference weight
PD.dryweight.initial <- ((PD.weight$Initial_01May)/(1-(DenSW0/PD.Arag))) #Calculates the dry weight in grams using Equation 1 from Spencer Davies 1989 calculates the density of the reference weight
PD.dryweight.final <- ((PD.weight$Initial_12June)/(1-(DenSW5/PD.Arag))) #Calculates the dry weight in grams using Equation 1 from Spencer Davies 1989 calculates the density of the reference weight
MC.growth.rate <- ((MC.dryweight.final-MC.dryweight.initial)/MC.dryweight.initial)*100/days #calculates growth in % per day (grams changed/grams initial/day)
PD.growth.rate <- ((PD.dryweight.final-PD.dryweight.initial)/PD.dryweight.initial)*100/days #calculates growth in % per day (grams changed/grams initial/day)
MC.growth <- data.frame(MC.weight,MC.growth.rate)
colnames(MC.growth) <- c("Species",	"Coral.ID",	"Treatment",	"Initial.weight",	"Final.weight",	"Growth.Rate")
PD.growth <- data.frame(PD.weight,PD.growth.rate)
colnames(PD.growth) <- c("Species",  "Coral.ID",	"Treatment",	"Initial.weight",	"Final.weight",	"Growth.Rate")
growth.rate <-rbind(MC.growth,PD.growth)
growth.counts <- aggregate(growth.rate["Growth.Rate"], by=growth.rate[c("Species","Treatment")], FUN=length)
growth.means <- aggregate(Growth.Rate ~ Species + Treatment, data=growth.rate, mean, na.rm = TRUE)
growth.se <- aggregate(Growth.Rate ~ Species + Treatment, data=growth.rate, std.error, na.rm = TRUE)
growth.means <- cbind(growth.means, growth.se$Growth.Rate)
colnames(growth.means) <- c("Species", "Treatment", "Growth.mean", "Growth.se")
growth.means[, "TS"] <- c("MC Amb", "PD Amb", "MC High", "PD High")
growth.means
Fig16 <- ggplot(growth.means, aes(x=Species, y=Growth.mean, fill=Treatment)) +
geom_bar() +
geom_bar(position=position_dodge(), stat="identity",
colour="black", # Use black outlines,
size=.3, # set line weight
show_guide=FALSE) + #remove slash from legend
scale_fill_manual(values=c("blue", "red")) +  #Set bar color
geom_errorbar(aes(ymin=Growth.mean-Growth.se, ymax=Growth.mean+Growth.se),
size=.3,    # set line weight
width=.2,   # set error bar width
position=position_dodge(.9)) + # offset the lines on the x axis so they match the bars and don't overlap
xlab("Species") + #Label the X Axis
ylab("Growth (% d-1)") + #Label the Y Axis
theme_bw() + #Set the background color
theme(axis.line = element_line(color = 'black'), #Set the axes color
panel.border = element_blank(), #Set the border
panel.grid.major = element_blank(), #Set the major gridlines
panel.grid.minor = element_blank(), #Set the minor gridlines
plot.background =element_blank(), #Set the plot background
legend.key = element_blank()) #Set plot legend key
Fig16 #View figure
###Testing ANOVA Assumptions
###Homogeneity of variance
#get unstandardized predicted and residual values
growth.results <-aov(log10(Growth.Rate) ~ Treatment + Species + Treatment*Species, data=growth.rate)
growth.stats <- anova(growth.results)
unstandardizedPredicted <- predict(growth.results)
unstandardizedResiduals <- resid(growth.results)
#get standardized values and plot to determine normality
standardizedPredicted <- (unstandardizedPredicted - mean(unstandardizedPredicted)) / sd(unstandardizedPredicted)
standardizedResiduals <- (unstandardizedResiduals - mean(unstandardizedResiduals)) / sd(unstandardizedResiduals)
#create standardized residuals plot
plot(standardizedPredicted, standardizedResiduals, main = "Standardized Residuals Plot", xlab = "Standardized Predicted Values", ylab = "Standardized Residuals")
#add horizontal line
abline(0,0)
leveneTest(log10(Growth.Rate) ~Treatment * Species, data=growth.rate)
###Data are normally distributed
results.stdres <- rstandard(growth.results)
qqnorm(results.stdres) # normal quantile plot
qqline(results.stdres) # adding a qline of comparison
shapiro.test(results.stdres) #runs a normality test using shapiro-wilk test on the standardized residuals
growth.HSD <- TukeyHSD(growth.results, ordered = FALSE, conf.level = 0.95)
growth.HSD
#calculate backtransformed means and SE
growth.rate$rate.trans <- log10(growth.rate$Growth.Rate)
sp.growth.trans.avg <- aggregate(rate.trans ~ Species, data=growth.rate, mean, na.rm = TRUE) #calculate the averages by Species
sp.growthbacktrans.avg <- 10^(sp.growth.trans.avg$rate.trans) #backtransform the average
growth.trans.avg <- aggregate(rate.trans  ~ Species + Treatment, data=growth.rate, mean, na.rm = TRUE) #calculate the averages by Species and Treatment
growth.trans.se <- aggregate(rate.trans  ~ Species + Treatment, data=growth.rate, std.error, na.rm = TRUE) #calculate the standard errors by Species and Treatment
growth.trans.std <- aggregate(rate.trans  ~ Species + Treatment, data=growth.rate, sd, na.rm = TRUE) #calculate the standard deviation by Species and Treatment
growth.trans <- growth.trans.avg #generate dataframe of averages
colnames(growth.trans) <- c("Species", "Treatment", "avg")
growth.trans$Upper <- growth.trans$avg+growth.trans.se$rate.trans
growth.trans$Lower <- growth.trans$avg-growth.trans.se$rate.trans
back.trans.growth <- growth.trans
back.trans.growth$avg <- 10^(growth.trans$avg)
back.trans.growth$Upper <- 10^(growth.trans$Upper)
back.trans.growth$Lower <- 10^(growth.trans$Lower)
back.trans.growth
#Plot backtransformed means and SE
Fig17 <- ggplot(data=back.trans.growth, aes(x=factor(Species), y=(avg), fill=Treatment)) + #plot methylation data averages
geom_bar()+
geom_bar(stat="identity", position=position_dodge(), #use values and offset position so bars don't overlap
colour="black", # set line color,
size=.3, #set line weight
show_guide=FALSE) + #remove slash from legend
scale_fill_manual(values=c("blue", "red")) + #set fill color for bars
geom_errorbar(aes(ymin=Lower, ymax=Upper), #plot standard errors
width=.2,                    # set width of the error bars
position=position_dodge(.9)) + #offset position so bars don't overlap
ggtitle("A") + #set plot title
xlab("Species") + #Label the X Axis
ylab("Growth (% d-1)") + #Label the Y Axis
theme_bw() + #Set the background color
theme(axis.line = element_line(color = 'black'), #Set the axes color
panel.border = element_blank(), #Set the border
panel.grid.major = element_blank(), #Set the major gridlines
panel.grid.minor = element_blank(), #Set the minor gridlines
plot.background =element_blank(), #Set the plot background
legend.key = element_blank(), #Set plot legend key
plot.title=element_text(hjust=0)) #Justify the title to the top left
Fig17 #View figure
#------------------------------------------------
#DNA METHYLATION ANALYSIS
#load DNA Methylation data
data <- read.csv("BM_Methylation.csv", header=TRUE, sep=",", na.strings="NA") #load data with a header, separated by commas, with NA as NA
data <- na.omit(data) #omit data rows that include NA
counts <- aggregate(data["Methylation"], by=data[c("Species","Treatment")], FUN=length) #count the sample sizes
avg <- aggregate(Methylation ~ Species + Treatment, data=data, mean, na.rm = TRUE) #calculate the averages by Species and Treatment
se <- aggregate(Methylation ~ Species + Treatment, data=data, std.error, na.rm = TRUE) #calculate the standard errors by Species and Treatment
methyl <- cbind(avg, se$Methylation) #generate dataframe of averages and standard errors
colnames(methyl) <- c("Species", "Treatment", "avg", "se" ) #rename columns of dataframe
Fig18 <- ggplot(data=methyl, aes(x=factor(Species), y=(avg), fill=Treatment)) + #plot methylation data averages
geom_bar()+
geom_bar(stat="identity", position=position_dodge(), #use values and offset position so bars don't overlap
colour="black", # set line color,
size=.3, #set line weight
show_guide=FALSE) + #remove slash from legend
scale_fill_manual(values=c("blue", "red")) + #set fill color for bars
geom_errorbar(aes(ymin=avg-se, ymax=avg+se), #plot standard errors
width=.2,                    # set width of the error bars
position=position_dodge(.9)) + #offset position so bars don't overlap
ggtitle("B") + #set plot title
xlab("Species") + #Label the X Axis
ylab("% DNA Methylation")+ #Label the Y Axis
theme_bw() + #Set the background color
theme(axis.line = element_line(color = 'black'), #Set the axes color
panel.border = element_blank(), #Set the border
panel.grid.major = element_blank(), #Set the major gridlines
panel.grid.minor = element_blank(), #Set the minor gridlines
plot.background =element_blank(), #Set the plot background
legend.key = element_blank(), #Set plot legend key
plot.title=element_text(hjust=0)) #Justify the title to the top left
Fig18 #View figure
###Testing ANOVA Assumptions
methylation.results <- aov((Methylation^0.25) ~Treatment * Species, data=data)
methylation.stats <- anova(methylation.results)
###Testing ANOVA Assumptions
###Homogeneity of variance
#get unstandardized predicted and residual values
unstandardizedPredicted <- predict(methylation.results)
unstandardizedResiduals <- resid(methylation.results)
#get standardized values and plot to determine homogeneity
standardizedPredicted <- (unstandardizedPredicted - mean(unstandardizedPredicted)) / sd(unstandardizedPredicted)
standardizedResiduals <- (unstandardizedResiduals - mean(unstandardizedResiduals)) / sd(unstandardizedResiduals)
#create standardized residuals plot
plot(standardizedPredicted, standardizedResiduals, main = "Standardized Residuals Plot", xlab = "Standardized Predicted Values", ylab = "Standardized Residuals")
#add horizontal line
abline(0,0)
leveneTest((Methylation^0.33) ~Treatment * Species, data=data)
###Data are normally distributed
results.stdres <- rstandard(methylation.results)
qqnorm(results.stdres) # normal quantile plot
qqline(results.stdres) # adding a qline of comparison
shapiro.test(results.stdres) #runs a normality test using shapiro-wilk test on the standardized residuals
methylation.HSD <- TukeyHSD(methylation.results, ordered = FALSE, conf.level = 0.95) #calculate pairwise differences between groups using Tukey's HSD Test
methylation.HSD #View results
MCPDavg <- aggregate(Methylation ~ Species, data=data, mean, na.rm = TRUE) #Calculate methylation average for each species
MCPDavg #View results
#calculate backtransformed means and SE
data$Methylation.trans <- (data$Methylation)^0.25
sp.trans.avg <- aggregate(Methylation.trans ~ Species, data=data, mean, na.rm = TRUE) #calculate the averages by Species
sp.backtrans.avg <- (sp.trans.avg$Methylation.trans)^4 #backtransform the average
trans.avg <- aggregate(Methylation.trans ~ Species + Treatment, data=data, mean, na.rm = TRUE) #calculate the averages by Species and Treatment
trans.se <- aggregate(Methylation.trans ~ Species + Treatment, data=data, std.error, na.rm = TRUE) #calculate the standard errors by Species and Treatment
trans.std <- aggregate(Methylation.trans ~ Species + Treatment, data=data, sd, na.rm = TRUE) #calculate the standard deviation by Species and Treatment
trans.methyl <- trans.avg #generate dataframe of averages
colnames(trans.methyl) <- c("Species", "Treatment", "avg")
trans.methyl$Upper <- trans.methyl$avg+trans.se$Methylation.trans
trans.methyl$Lower <- trans.methyl$avg-trans.se$Methylation.trans
back.trans.methyl <- trans.methyl
back.trans.methyl$avg <- (trans.methyl$avg)^4
back.trans.methyl$Upper <- (trans.methyl$Upper)^4
back.trans.methyl$Lower <- (trans.methyl$Lower)^4
back.trans.methyl
#Plot backtransformed means and SE
Fig19 <- ggplot(data=back.trans.methyl, aes(x=factor(Species), y=(avg), fill=Treatment)) + #plot methylation data averages
geom_bar()+
geom_bar(stat="identity", position=position_dodge(), #use values and offset position so bars don't overlap
colour="black", # set line color,
size=.3, #set line weight
show_guide=FALSE) + #remove slash from legend
scale_fill_manual(values=c("blue", "red")) + #set fill color for bars
geom_errorbar(aes(ymin=Lower, ymax=Upper), #plot standard errors
width=.2,                    # set width of the error bars
position=position_dodge(.9)) + #offset position so bars don't overlap
ggtitle("B") + #set plot title
xlab("Species") + #Label the X Axis
ylab("% DNA Methylation")+ #Label the Y Axis
theme_bw() + #Set the background color
theme(axis.line = element_line(color = 'black'), #Set the axes color
panel.border = element_blank(), #Set the border
panel.grid.major = element_blank(), #Set the major gridlines
panel.grid.minor = element_blank(), #Set the minor gridlines
plot.background =element_blank(), #Set the plot background
legend.key = element_blank(), #Set plot legend key
plot.title=element_text(hjust=0)) #Justify the title to the top left
Fig19 #View figure
#------------------------------------------------
#CAPTURE ALL STATISTICAL OUTPUT TO A FILE
capture.output(MC.OPLSResults, PD.OPLSResults, ALL.OPLSResults, growth.results, growth.stats, growth.HSD, methylation.results, methylation.stats, methylation.HSD, file="Bulk_Methylation_Statistical_Results.txt")
Figure.S1 <- arrangeGrob(Fig3, Fig2, Fig1, ncol=3)
ggsave(file="FigureS1_Manuscript.pdf", Figure.S1, width = 11, height = 4, units = c("in"))
Figure.S2 <- arrangeGrob(Fig6, Fig9, ncol=2)
ggsave(file="FigureS2_Manuscript.pdf", Figure.S2, width = 11, height = 4, units = c("in"))
Figure.1 <- arrangeGrob(Fig11, Fig12, ncol=2)
ggsave(file="Figure1_Manuscript.pdf", Figure.1, width = 11, height = 4, units = c("in"))
Figure.2 <- arrangeGrob(Fig13, Fig14, Fig15, ncol=1)
ggsave(file="Figure2_Manuscript.pdf", Figure.2, width = 5, height = 11, units = c("in"))
Figure.3 <- arrangeGrob(Fig17, Fig19, ncol=2)
ggsave(file="Figure3_Manuscript.pdf", Figure.3, width = 11, height = 4, units = c("in"))
weight <- read.csv("BM_Buoyant_Weight.csv", header=TRUE, sep=",", na.strings="NA") #load data with a header, separated by commas, with NA as NA
getwd
getwd()
setwd("/Users/hputnam/Publications/In_Review/Bulk_Methylation/Coral_DNAMethylation_Plasticity/R_Analysis/Data") #set working directory
#load weight data
weight <- read.csv("BM_Buoyant_Weight.csv", header=TRUE, sep=",", na.strings="NA") #load data with a header, separated by commas, with NA as NA
PD.Arag <- 2.78 #g cm-3, set aragonite density for Pocillopora from literature
MC.Arag <- 2.03 #g cm-3, set aragonite density for Montipora from literature
#Pocillopora Arag = 2.78 g cm-3 Spencer-Davies 1989 Mar Bio 101:389-395, Al-Sofyani and Floos 2013 Oecologia 55:917-935
#Montipora Arag = 2.03 g cm-3 average from table 2 in Anthony 2003 Functional Ecology 17:246-259
#TimeInitial date=20140501
Temp0 <- 23.92 #Temperature of the measurement
RefDry0 <- 39.110 #weight of solid glass dry reference in air
RefSW0 <- 21.129 #weight of solid glass reference in seawater
RefFW0 <- 21.582 #weight of solid glass reference in freshwater
DenFW0 <- ((-0.000005*Temp0*Temp0)+(0.000007*Temp0)+1.0001) #g cm-3 Calculates density of the freshwater as a function of temperature
DenRef0 <- ((RefDry0*DenFW0)/(RefDry0-RefFW0)) #g cm-3 Equation 4 from Spencer Davies 1989 calculates the density of the reference weight
DenSW0 <- ((DenRef0*(RefDry0-RefSW0))/(RefDry0))  #g cm-3 Equation 3 from Spencer Davies 1989 using the density of the calcualted reference weight
#TimeFinal date=20140612
Temp5 <- 26.24 #Temperature of the measurement
RefDry5 <- 39.110 #weight of solid glass dry reference in air
RefSW5 <- 21.128 #weight of solid glass reference in seawater
RefFW5 <- 21.572 #weight of solid glass reference in freshwater
DenFW5 <- ((-0.000005*Temp5*Temp5)+(0.000007*Temp5)+1.0001) #g cm-3 Calculates density of the freshwater as a function of temperature
DenRef5 <- ((RefDry5*DenFW5)/(RefDry5-RefFW5)) #g cm-3 Equation 4 from Spencer Davies 1989 calculates the density of the reference weight
DenSW5 <- ((DenRef5*(RefDry5-RefSW5))/(RefDry5))  #g cm-3 Equation 3 from Spencer Davies 1989 using the density of the calcualted reference weight
days <- 43
#Montipora Dry Weight
#Subset weights by species
MC.weight <-subset(weight, weight$Species=='Montipora capitata')
PD.weight <-subset(weight, weight$Species=='Pocillopora damicornis')
MC.dryweight.initial <- ((MC.weight$Initial_01May)/(1-(DenSW0/MC.Arag))) #Calculates the dry weight in grams using Equation 1 from Spencer Davies 1989 calculates the density of the reference weight
MC.dryweight.final <- ((MC.weight$Initial_12June)/(1-(DenSW5/MC.Arag))) #Calculates the dry weight in grams using Equation 1 from Spencer Davies 1989 calculates the density of the reference weight
PD.dryweight.initial <- ((PD.weight$Initial_01May)/(1-(DenSW0/PD.Arag))) #Calculates the dry weight in grams using Equation 1 from Spencer Davies 1989 calculates the density of the reference weight
PD.dryweight.final <- ((PD.weight$Initial_12June)/(1-(DenSW5/PD.Arag))) #Calculates the dry weight in grams using Equation 1 from Spencer Davies 1989 calculates the density of the reference weight
MC.growth.rate <- ((MC.dryweight.final-MC.dryweight.initial)/MC.dryweight.initial)*100/days #calculates growth in % per day (grams changed/grams initial/day)
PD.growth.rate <- ((PD.dryweight.final-PD.dryweight.initial)/PD.dryweight.initial)*100/days #calculates growth in % per day (grams changed/grams initial/day)
MC.growth <- data.frame(MC.weight,MC.growth.rate)
colnames(MC.growth) <- c("Species",	"Coral.ID",	"Treatment",	"Initial.weight",	"Final.weight",	"Growth.Rate")
PD.growth <- data.frame(PD.weight,PD.growth.rate)
colnames(PD.growth) <- c("Species",  "Coral.ID",	"Treatment",	"Initial.weight",	"Final.weight",	"Growth.Rate")
growth.rate <-rbind(MC.growth,PD.growth)
growth.counts <- aggregate(growth.rate["Growth.Rate"], by=growth.rate[c("Species","Treatment")], FUN=length)
growth.means <- aggregate(Growth.Rate ~ Species + Treatment, data=growth.rate, mean, na.rm = TRUE)
growth.se <- aggregate(Growth.Rate ~ Species + Treatment, data=growth.rate, std.error, na.rm = TRUE)
growth.means <- cbind(growth.means, growth.se$Growth.Rate)
colnames(growth.means) <- c("Species", "Treatment", "Growth.mean", "Growth.se")
growth.means[, "TS"] <- c("MC Amb", "PD Amb", "MC High", "PD High")
growth.means
Fig16 <- ggplot(growth.means, aes(x=Species, y=Growth.mean, fill=Treatment)) +
geom_bar() +
geom_bar(position=position_dodge(), stat="identity",
colour="black", # Use black outlines,
size=.3, # set line weight
show_guide=FALSE) + #remove slash from legend
scale_fill_manual(values=c("blue", "red")) +  #Set bar color
geom_errorbar(aes(ymin=Growth.mean-Growth.se, ymax=Growth.mean+Growth.se),
size=.3,    # set line weight
width=.2,   # set error bar width
position=position_dodge(.9)) + # offset the lines on the x axis so they match the bars and don't overlap
xlab("Species") + #Label the X Axis
ylab("Growth (% d-1)") + #Label the Y Axis
theme_bw() + #Set the background color
theme(axis.line = element_line(color = 'black'), #Set the axes color
panel.border = element_blank(), #Set the border
panel.grid.major = element_blank(), #Set the major gridlines
panel.grid.minor = element_blank(), #Set the minor gridlines
plot.background =element_blank(), #Set the plot background
legend.key = element_blank()) #Set plot legend key
Fig16 #View figure
###Testing ANOVA Assumptions
###Homogeneity of variance
#get unstandardized predicted and residual values
growth.results <-aov(log10(Growth.Rate) ~ Treatment + Species + Treatment*Species, data=growth.rate)
growth.stats <- anova(growth.results)
unstandardizedPredicted <- predict(growth.results)
unstandardizedResiduals <- resid(growth.results)
#get standardized values and plot to determine normality
standardizedPredicted <- (unstandardizedPredicted - mean(unstandardizedPredicted)) / sd(unstandardizedPredicted)
standardizedResiduals <- (unstandardizedResiduals - mean(unstandardizedResiduals)) / sd(unstandardizedResiduals)
#create standardized residuals plot
plot(standardizedPredicted, standardizedResiduals, main = "Standardized Residuals Plot", xlab = "Standardized Predicted Values", ylab = "Standardized Residuals")
#add horizontal line
abline(0,0)
leveneTest(log10(Growth.Rate) ~Treatment * Species, data=growth.rate)
###Data are normally distributed
results.stdres <- rstandard(growth.results)
qqnorm(results.stdres) # normal quantile plot
qqline(results.stdres) # adding a qline of comparison
shapiro.test(results.stdres) #runs a normality test using shapiro-wilk test on the standardized residuals
growth.HSD <- TukeyHSD(growth.results, ordered = FALSE, conf.level = 0.95)
growth.HSD
#calculate backtransformed means and SE
growth.rate$rate.trans <- log10(growth.rate$Growth.Rate)
sp.growth.trans.avg <- aggregate(rate.trans ~ Species, data=growth.rate, mean, na.rm = TRUE) #calculate the averages by Species
sp.growthbacktrans.avg <- 10^(sp.growth.trans.avg$rate.trans) #backtransform the average
growth.trans.avg <- aggregate(rate.trans  ~ Species + Treatment, data=growth.rate, mean, na.rm = TRUE) #calculate the averages by Species and Treatment
growth.trans.se <- aggregate(rate.trans  ~ Species + Treatment, data=growth.rate, std.error, na.rm = TRUE) #calculate the standard errors by Species and Treatment
growth.trans.std <- aggregate(rate.trans  ~ Species + Treatment, data=growth.rate, sd, na.rm = TRUE) #calculate the standard deviation by Species and Treatment
growth.trans <- growth.trans.avg #generate dataframe of averages
colnames(growth.trans) <- c("Species", "Treatment", "avg")
growth.trans$Upper <- growth.trans$avg+growth.trans.se$rate.trans
growth.trans$Lower <- growth.trans$avg-growth.trans.se$rate.trans
back.trans.growth <- growth.trans
back.trans.growth$avg <- 10^(growth.trans$avg)
back.trans.growth$Upper <- 10^(growth.trans$Upper)
back.trans.growth$Lower <- 10^(growth.trans$Lower)
back.trans.growth
#Plot backtransformed means and SE
Fig17 <- ggplot(data=back.trans.growth, aes(x=factor(Species), y=(avg), fill=Treatment)) + #plot methylation data averages
geom_bar()+
geom_bar(stat="identity", position=position_dodge(), #use values and offset position so bars don't overlap
colour="black", # set line color,
size=.3, #set line weight
show_guide=FALSE) + #remove slash from legend
scale_fill_manual(values=c("blue", "red")) + #set fill color for bars
geom_errorbar(aes(ymin=Lower, ymax=Upper), #plot standard errors
width=.2,                    # set width of the error bars
position=position_dodge(.9)) + #offset position so bars don't overlap
ggtitle("A") + #set plot title
xlab("Species") + #Label the X Axis
ylab("Growth (% d-1)") + #Label the Y Axis
theme_bw() + #Set the background color
theme(axis.line = element_line(color = 'black'), #Set the axes color
panel.border = element_blank(), #Set the border
panel.grid.major = element_blank(), #Set the major gridlines
panel.grid.minor = element_blank(), #Set the minor gridlines
plot.background =element_blank(), #Set the plot background
legend.key = element_blank(), #Set plot legend key
plot.title=element_text(hjust=0)) #Justify the title to the top left
Fig17 #View figure
#------------------------------------------------
#DNA METHYLATION ANALYSIS
#load DNA Methylation data
data <- read.csv("BM_Methylation.csv", header=TRUE, sep=",", na.strings="NA") #load data with a header, separated by commas, with NA as NA
data <- na.omit(data) #omit data rows that include NA
counts <- aggregate(data["Methylation"], by=data[c("Species","Treatment")], FUN=length) #count the sample sizes
avg <- aggregate(Methylation ~ Species + Treatment, data=data, mean, na.rm = TRUE) #calculate the averages by Species and Treatment
se <- aggregate(Methylation ~ Species + Treatment, data=data, std.error, na.rm = TRUE) #calculate the standard errors by Species and Treatment
methyl <- cbind(avg, se$Methylation) #generate dataframe of averages and standard errors
colnames(methyl) <- c("Species", "Treatment", "avg", "se" ) #rename columns of dataframe
Fig18 <- ggplot(data=methyl, aes(x=factor(Species), y=(avg), fill=Treatment)) + #plot methylation data averages
geom_bar()+
geom_bar(stat="identity", position=position_dodge(), #use values and offset position so bars don't overlap
colour="black", # set line color,
size=.3, #set line weight
show_guide=FALSE) + #remove slash from legend
scale_fill_manual(values=c("blue", "red")) + #set fill color for bars
geom_errorbar(aes(ymin=avg-se, ymax=avg+se), #plot standard errors
width=.2,                    # set width of the error bars
position=position_dodge(.9)) + #offset position so bars don't overlap
ggtitle("B") + #set plot title
xlab("Species") + #Label the X Axis
ylab("% DNA Methylation")+ #Label the Y Axis
theme_bw() + #Set the background color
theme(axis.line = element_line(color = 'black'), #Set the axes color
panel.border = element_blank(), #Set the border
panel.grid.major = element_blank(), #Set the major gridlines
panel.grid.minor = element_blank(), #Set the minor gridlines
plot.background =element_blank(), #Set the plot background
legend.key = element_blank(), #Set plot legend key
plot.title=element_text(hjust=0)) #Justify the title to the top left
Fig18 #View figure
###Testing ANOVA Assumptions
methylation.results <- aov((Methylation^0.25) ~Treatment * Species, data=data)
methylation.stats <- anova(methylation.results)
###Testing ANOVA Assumptions
###Homogeneity of variance
#get unstandardized predicted and residual values
unstandardizedPredicted <- predict(methylation.results)
unstandardizedResiduals <- resid(methylation.results)
#get standardized values and plot to determine homogeneity
standardizedPredicted <- (unstandardizedPredicted - mean(unstandardizedPredicted)) / sd(unstandardizedPredicted)
standardizedResiduals <- (unstandardizedResiduals - mean(unstandardizedResiduals)) / sd(unstandardizedResiduals)
#create standardized residuals plot
plot(standardizedPredicted, standardizedResiduals, main = "Standardized Residuals Plot", xlab = "Standardized Predicted Values", ylab = "Standardized Residuals")
#add horizontal line
abline(0,0)
leveneTest((Methylation^0.33) ~Treatment * Species, data=data)
###Data are normally distributed
results.stdres <- rstandard(methylation.results)
qqnorm(results.stdres) # normal quantile plot
qqline(results.stdres) # adding a qline of comparison
shapiro.test(results.stdres) #runs a normality test using shapiro-wilk test on the standardized residuals
methylation.HSD <- TukeyHSD(methylation.results, ordered = FALSE, conf.level = 0.95) #calculate pairwise differences between groups using Tukey's HSD Test
methylation.HSD #View results
MCPDavg <- aggregate(Methylation ~ Species, data=data, mean, na.rm = TRUE) #Calculate methylation average for each species
MCPDavg #View results
#calculate backtransformed means and SE
data$Methylation.trans <- (data$Methylation)^0.25
sp.trans.avg <- aggregate(Methylation.trans ~ Species, data=data, mean, na.rm = TRUE) #calculate the averages by Species
sp.backtrans.avg <- (sp.trans.avg$Methylation.trans)^4 #backtransform the average
trans.avg <- aggregate(Methylation.trans ~ Species + Treatment, data=data, mean, na.rm = TRUE) #calculate the averages by Species and Treatment
trans.se <- aggregate(Methylation.trans ~ Species + Treatment, data=data, std.error, na.rm = TRUE) #calculate the standard errors by Species and Treatment
trans.std <- aggregate(Methylation.trans ~ Species + Treatment, data=data, sd, na.rm = TRUE) #calculate the standard deviation by Species and Treatment
trans.methyl <- trans.avg #generate dataframe of averages
colnames(trans.methyl) <- c("Species", "Treatment", "avg")
trans.methyl$Upper <- trans.methyl$avg+trans.se$Methylation.trans
trans.methyl$Lower <- trans.methyl$avg-trans.se$Methylation.trans
back.trans.methyl <- trans.methyl
back.trans.methyl$avg <- (trans.methyl$avg)^4
back.trans.methyl$Upper <- (trans.methyl$Upper)^4
back.trans.methyl$Lower <- (trans.methyl$Lower)^4
back.trans.methyl
#Plot backtransformed means and SE
Fig19 <- ggplot(data=back.trans.methyl, aes(x=factor(Species), y=(avg), fill=Treatment)) + #plot methylation data averages
geom_bar()+
geom_bar(stat="identity", position=position_dodge(), #use values and offset position so bars don't overlap
colour="black", # set line color,
size=.3, #set line weight
show_guide=FALSE) + #remove slash from legend
scale_fill_manual(values=c("blue", "red")) + #set fill color for bars
geom_errorbar(aes(ymin=Lower, ymax=Upper), #plot standard errors
width=.2,                    # set width of the error bars
position=position_dodge(.9)) + #offset position so bars don't overlap
ggtitle("B") + #set plot title
xlab("Species") + #Label the X Axis
ylab("% DNA Methylation")+ #Label the Y Axis
theme_bw() + #Set the background color
theme(axis.line = element_line(color = 'black'), #Set the axes color
panel.border = element_blank(), #Set the border
panel.grid.major = element_blank(), #Set the major gridlines
panel.grid.minor = element_blank(), #Set the minor gridlines
plot.background =element_blank(), #Set the plot background
legend.key = element_blank(), #Set plot legend key
plot.title=element_text(hjust=0)) #Justify the title to the top left
Fig19 #View figure
#------------------------------------------------
#CAPTURE ALL STATISTICAL OUTPUT TO A FILE
capture.output(MC.OPLSResults, PD.OPLSResults, ALL.OPLSResults, growth.results, growth.stats, growth.HSD, methylation.results, methylation.stats, methylation.HSD, file="Bulk_Methylation_Statistical_Results.txt")
Figure.S1 <- arrangeGrob(Fig3, Fig2, Fig1, ncol=3)
ggsave(file="FigureS1_Manuscript.pdf", Figure.S1, width = 11, height = 4, units = c("in"))
Figure.S2 <- arrangeGrob(Fig6, Fig9, ncol=2)
ggsave(file="FigureS2_Manuscript.pdf", Figure.S2, width = 11, height = 4, units = c("in"))
Figure.1 <- arrangeGrob(Fig11, Fig12, ncol=2)
ggsave(file="Figure1_Manuscript.pdf", Figure.1, width = 11, height = 4, units = c("in"))
Figure.2 <- arrangeGrob(Fig13, Fig14, Fig15, ncol=1)
ggsave(file="Figure2_Manuscript.pdf", Figure.2, width = 5, height = 11, units = c("in"))
Figure.3 <- arrangeGrob(Fig17, Fig19, ncol=2)
ggsave(file="Figure3_Manuscript.pdf", Figure.3, width = 11, height = 4, units = c("in"))
View(cleaned.all.data)
View(cleaned.all.info)
Sig.Sp.Bin <- cleaned.data[,colnames(cleaned.data)%in%sig_metabolites] #data matrix with only significant bins
cleaned.data #data matrix of all bins
Sp.corr <- cor(as.matrix(Sig.Sp.Bin), as.matrix(cleaned.data))
barplot(Sp.corr[1,])
Sig.Sp.Bin <- cleaned.data[,colnames(cleaned.data)%in%sig_metabolites] #data matrix with only significant bins
Sig.Sp.Bin <- cleaned.data[,colnames(cleaned.data)%in%ALL.sig_metabolites] #data matrix with only significant bins
cleaned.data #data matrix of all bins
Sp.corr <- cor(as.matrix(Sig.Sp.Bin), as.matrix(cleaned.data))
barplot(Sp.corr[1,])
Sp.corr
View(Sp.corr)
barplot(Sp.corr[1,]>0.6)
barplot(Sp.corr[2,]>0.6)
barplot(Sp.corr[2,]>0.4)
barplot(Sp.corr[2,]>0.5)
barplot(Sp.corr[5,]>0.5)
barplot(Sp.corr[5,])
barplot(Sp.corr[5,]>0.38)
barplot(Sp.corr[6,])
barplot(Sp.corr[6,]>0.6)
barplot(Sp.corr[7,])
barplot(Sp.corr[7,]>0.9)
barplot(Sp.corr[7,]>0.78)
barplot(Sp.corr[8,])
barplot(Sp.corr[8,]>0.6)
barplot(Sp.corr[9,])
barplot(Sp.corr[9,]>0.6)
barplot(Sp.corr[9,])
barplot(Sp.corr[9,]>0.7)
barplot(Sp.corr[5,]>0.7)
barplot(Sp.corr[5,])
barplot(Sp.corr[6,])
barplot(Sp.corr[6,]>0.7)
barplot(Sp.corr[6,])
barplot(Sp.corr[12,])
barplot(Sp.corr[13,])
barplot(Sp.corr[13,]>0.8)
barplot(Sp.corr[15,]>0.8)
barplot(Sp.corr[15,])
barplot(Sp.corr[15,]>0.7)
barplot(Sp.corr[17,])
barplot(Sp.corr[17,]>0.8)
barplot(Sp.corr[17,])
write.csv(PD.data, file="PD.csv")
write.csv(PD.info, file="PDinfo.csv")
Perch.PD
View(cleaned.PD.data)
cleaned.PD.data
write.csv(cleaned.PD.data, file="PD.csv")
write.csv(cleaned.PD.info, file="PD.csv")
write.csv(cleaned.PD.info, file="PDinfo.csv")
write.csv(cleaned.PD.data, file="PD.csv")

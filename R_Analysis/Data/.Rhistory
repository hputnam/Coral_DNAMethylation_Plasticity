which(colSums(PD.amb) ==0) #check again for any zero columns
#Calculated RSD BY SPECIES and Treatment:  %RSD = (bin sd / bin mean) * 100
MC.RSD.high <-(apply(MC.high,2, sd)/colMeans(MC.high)*100) #calculate %RSD
MC.RSD.amb <-(apply(MC.amb,2, sd)/colMeans(MC.amb)*100) #calculate %RSD
range(MC.RSD.high) #view range RSD
range(MC.RSD.amb) #view range RSD
PD.RSD.high <-(apply(PD.high,2, sd)/colMeans(PD.high)*100) #calculate %RSD
PD.RSD.amb <-(apply(PD.amb,2, sd)/colMeans(PD.amb)*100) #calculate %RSD
range(PD.RSD.high) #view range RSD
range(PD.RSD.amb) #view range RSD
df.m<-melt(cbind(MC.RSD.high, MC.RSD.amb, PD.RSD.high, PD.RSD.amb)) #combines and melts data into long format
RSDdf.omit<-na.omit(df.m) #removes NA values
shapiro.test(RSDdf.omit$value) # checks for normality: non-normal data
hist(RSDdf.omit$value)
RSD.result <-kruskal.test(RSDdf.omit$value, RSDdf.omit$X2, p.adj='bonferroni') #performs Kruskal_walis One Way Analysis of Variance
RSD.result
MC.RSD.H.data <- subset(RSDdf.omit, RSDdf.omit$X2=="MC.RSD.high")
MC.RSD.A.data <- subset(RSDdf.omit, RSDdf.omit$X2=="MC.RSD.amb")
MC.RSD.data <- rbind(MC.RSD.H.data,MC.RSD.A.data)
Names <- c("Ambient", "High", "Ambient", "High")
Fig.RSD <- ggplot(RSDdf.omit, aes(X2, value)) +
geom_boxplot(data=RSDdf.omit, aes(X2, value, fill=X2)) +
xlab("Treatment") + #Label the X Axis
ylab("% RSD") + #Label the Y Axis
ylim(0,500) + #set the y axis limit
theme_bw() + #Set the background color
scale_fill_manual(values=c("blue", "red","blue", "red")) + #set plot colors
theme(axis.line = element_line(color = 'black'), #Set the axes color
axis.title=element_text(size=14,face="bold"), #Set axis format
panel.border = element_blank(), #Set the border
panel.grid.major = element_blank(), #Set the major gridlines
panel.grid.minor = element_blank(), #Set the minor gridlines
plot.background =element_blank(), #Set the plot background
legend.position="none") + #remove legend
scale_x_discrete(breaks=c("MC.RSD.amb","MC.RSD.high","PD.RSD.amb","PD.RSD.high"), labels=c("M. capitata", "M. capitata", "P. damicornis","P. damicornis"))
Fig.RSD
#------------------------------------------------
#Growth Analysis
setwd(file.path(mainDir, 'Data')) #set data path
#load weight data
weight <- read.csv("BM_Buoyant_Weight_Repeated.csv", header=TRUE, sep=",", na.strings="NA") #load data with a header, separated by commas, with NA as NA
PD.Arag <- 2.78 #g cm-3, set aragonite density for Pocillopora from literature
MC.Arag <- 2.03 #g cm-3, set aragonite density for Montipora from literature
#Pocillopora Arag = 2.78 g cm-3 Spencer-Davies 1989 Mar Bio 101:389-395, Al-Sofyani and Floos 2013 Oecologia 55:917-935
#Montipora Arag = 2.03 g cm-3 average from table 2 in Anthony 2003 Functional Ecology 17:246-259
#TimeInitial date=20140501
Temp0 <- 23.92 #Temperature of the measurement
RefDry0 <- 39.110 #weight of solid glass dry reference in air
RefSW0 <- 21.129 #weight of solid glass reference in seawater
RefFW0 <- 21.582 #weight of solid glass reference in freshwater
DenFW0 <- ((-0.000005*Temp0*Temp0)+(0.000007*Temp0)+1.0001) #g cm-3 Calculates density of the freshwater as a function of temperature
DenRef0 <- ((RefDry0*DenFW0)/(RefDry0-RefFW0)) #g cm-3 Equation 4 from Spencer Davies 1989 calculates the density of the reference weight
DenSW0 <- ((DenRef0*(RefDry0-RefSW0))/(RefDry0))  #g cm-3 Equation 3 from Spencer Davies 1989 using the density of the calcualted reference weight
#Week2 date=20140515
Temp2 <- 25.45 #Temperature of the measurement
RefDry2 <- 39.111 #weight of solid glass dry reference in air
RefSW2 <- 21.137 #weight of solid glass reference in seawater
RefFW2 <- 21.595 #weight of solid glass reference in freshwater
DenFW2 <- ((-0.000005*Temp2*Temp2)+(0.000007*Temp2)+1.0001) #g cm-3 Calculates density of the freshwater as a function of temperature
DenRef2 <- ((RefDry2*DenFW2)/(RefDry2-RefFW2)) #g cm-3 Equation 4 from Spencer Davies 1989 calculates the density of the reference weight
DenSW2 <- ((DenRef2*(RefDry2-RefSW2))/(RefDry2))  #g cm-3 Equation 3 from Spencer Davies 1989 using the density of the calcualted reference weight
#Week4 date=20140529
Temp4 <- 25.72 #Temperature of the measurement
RefDry4 <- 39.112 #weight of solid glass dry reference in air
RefSW4 <- 21.148 #weight of solid glass reference in seawater
RefFW4 <- 21.582 #weight of solid glass reference in freshwater
DenFW4 <- ((-0.000005*Temp4*Temp4)+(0.000007*Temp4)+1.0001) #g cm-3 Calculates density of the freshwater as a function of temperature
DenRef4 <- ((RefDry4*DenFW4)/(RefDry4-RefFW4)) #g cm-3 Equation 4 from Spencer Davies 1989 calculates the density of the reference weight
DenSW4 <- ((DenRef4*(RefDry4-RefSW4))/(RefDry4))  #g cm-3 Equation 3 from Spencer Davies 1989 using the density of the calcualted reference weight
#Week6 date=20140612
Temp6 <- 26.24 #Temperature of the measurement
RefDry6 <- 39.110 #weight of solid glass dry reference in air
RefSW6 <- 21.128 #weight of solid glass reference in seawater
RefFW6 <- 21.572 #weight of solid glass reference in freshwater
DenFW6 <- ((-0.000005*Temp6*Temp6)+(0.000007*Temp6)+1.0001) #g cm-3 Calculates density of the freshwater as a function of temperature
DenRef6 <- ((RefDry6*DenFW6)/(RefDry6-RefFW6)) #g cm-3 Equation 4 from Spencer Davies 1989 calculates the density of the reference weight
DenSW6 <- ((DenRef6*(RefDry6-RefSW6))/(RefDry6))  #g cm-3 Equation 3 from Spencer Davies 1989 using the density of the calcualted reference weight
days <- 14 #number of days between weighings
MC.weight <-subset(weight, weight$Species=='Montipora capitata') #subset MC data to apply MC specific skeletal density
PD.weight <-subset(weight, weight$Species=='Pocillopora damicornis') #subset MC data to apply MC specific skeletal density
PD.DryWeight1 <- ((PD.weight$Final_01May)/(1-(DenSW0/PD.Arag))) #calculate dry weight Spencer Davies 1989 Eq 4
PD.DryWeight2 <- ((PD.weight$Initial_15May)/(1-(DenSW2/PD.Arag))) #calculate dry weight Spencer Davies 1989 Eq 4
PD.DryWeight3 <- ((PD.weight$Final_15May)/(1-(DenSW2/PD.Arag))) #calculate dry weight Spencer Davies 1989 Eq 4
PD.DryWeight4 <- ((PD.weight$Initial_29May)/(1-(DenSW4/PD.Arag))) #calculate dry weight Spencer Davies 1989 Eq 4
PD.DryWeight5 <- ((PD.weight$Final_29May)/(1-(DenSW4/PD.Arag))) #calculate dry weight Spencer Davies 1989 Eq 4
PD.DryWeight6 <- ((PD.weight$Initial_12June)/(1-(DenSW6/PD.Arag))) #calculate dry weight Spencer Davies 1989 Eq 4
PD.G.week2 <- ((PD.DryWeight2-PD.DryWeight1)/(PD.DryWeight1))*100/(days) #calculate growth rate in % growth per day normalized to initial mass
PD.G.week4 <- ((PD.DryWeight4-PD.DryWeight3)/(PD.DryWeight3))*100/(days) #calculate growth rate in % growth per day normalized to initial mass
PD.G.week6 <- ((PD.DryWeight6-PD.DryWeight5)/(PD.DryWeight5))*100/(days) #calculate growth rate in % growth per day normalized to initial mass
PD.G.data <- cbind(PD.weight,PD.G.week2,PD.G.week4,PD.G.week6) #combine growth rate data and metadata
colnames(PD.G.data) <- c("Species",  "Coral.ID",  "Treatment",	"Initial_01May",	"Final_01May",	"Initial_15May",	"Final_15May",	"Initial_29May",	"Final_29May",	"Initial_12June",	"Week2",	"Week4",	"Week6")
#Montipora Dry Weight
#Subset weights by species
MC.DryWeight1 <- ((MC.weight$Final_01May)/(1-(DenSW0/MC.Arag))) #calculate dry weight Spencer Davies 1989 Eq 4
MC.DryWeight2 <- ((MC.weight$Initial_15May)/(1-(DenSW2/MC.Arag))) #calculate dry weight Spencer Davies 1989 Eq 4
MC.DryWeight3 <- ((MC.weight$Final_15May)/(1-(DenSW2/MC.Arag))) #calculate dry weight Spencer Davies 1989 Eq 4
MC.DryWeight4 <- ((MC.weight$Initial_29May)/(1-(DenSW4/MC.Arag))) #calculate dry weight Spencer Davies 1989 Eq 4
MC.DryWeight5 <- ((MC.weight$Final_29May)/(1-(DenSW4/MC.Arag))) #calculate dry weight Spencer Davies 1989 Eq 4
MC.DryWeight6 <- ((MC.weight$Initial_12June)/(1-(DenSW6/MC.Arag))) #calculate dry weight Spencer Davies 1989 Eq 4
MC.G.week2 <- ((MC.DryWeight2-MC.DryWeight1)/(MC.DryWeight1))*100/(days) #calculate growth rate in % growth per day normalized to initial mass
MC.G.week4 <- ((MC.DryWeight4-MC.DryWeight3)/(MC.DryWeight3))*100/(days) #calculate growth rate in % growth per day normalized to initial mass
MC.G.week6 <- ((MC.DryWeight6-MC.DryWeight5)/(MC.DryWeight5))*100/(days) #calculate growth rate in % growth per day normalized to initial mass
MC.G.data <- cbind(MC.weight,MC.G.week2,MC.G.week4,MC.G.week6) #combine growth rate data and metadata
colnames(MC.G.data) <- c("Species",  "Coral.ID",	"Treatment",	"Initial_01May",	"Final_01May",	"Initial_15May",	"Final_15May",	"Initial_29May",	"Final_29May",	"Initial_12June",	"Week2",	"Week4",	"Week6")
growth.rate <-rbind(MC.G.data,PD.G.data)
G.counts.2 <- aggregate(growth.rate["Week2"], by=growth.rate[c("Species","Treatment")], FUN=length)
G.means.2 <- aggregate(Week2 ~ Species + Treatment, data=growth.rate, mean, na.rm = TRUE)
G.se.2 <- aggregate(Week2 ~ Species + Treatment, data=growth.rate, std.error, na.rm = TRUE)
G.means.2 <- cbind(G.means.2, G.se.2$Week2)
G.means.2$Time <- c("Week2")
colnames(G.means.2) <- c("Species", "Treatment", "Mean", "SE", "Time")
G.means.2
G.counts.4 <- aggregate(growth.rate["Week4"], by=growth.rate[c("Species","Treatment")], FUN=length)
G.means.4 <- aggregate(Week4 ~ Species + Treatment, data=growth.rate, mean, na.rm = TRUE)
G.se.4 <- aggregate(Week4 ~ Species + Treatment, data=growth.rate, std.error, na.rm = TRUE)
G.means.4 <- cbind(G.means.4, G.se.4$Week4)
G.means.4$Time <- c("Week4")
colnames(G.means.4) <- c("Species", "Treatment", "Mean", "SE", "Time")
G.means.4
G.counts.6 <- aggregate(growth.rate["Week6"], by=growth.rate[c("Species","Treatment")], FUN=length)
G.means.6 <- aggregate(Week6 ~ Species + Treatment, data=growth.rate, mean, na.rm = TRUE)
G.se.6 <- aggregate(Week6 ~ Species + Treatment, data=growth.rate, std.error, na.rm = TRUE)
G.means.6 <- cbind(G.means.6, G.se.6$Week6)
G.means.6$Time <- c("Week6")
colnames(G.means.6) <- c("Species", "Treatment", "Mean", "SE", "Time")
G.means.6
PH
G <- rbind(G.means.2, G.means.4, G.means.6)
G$TS <- c("MC Amb", "PD Amb", "MC High", "PD High","MC Amb", "PD Amb", "MC High", "PD High","MC Amb", "PD Amb", "MC High", "PD High")
Fig16 <- ggplot(G, aes(x=Time, y=Mean, group=TS), position="dodge") +
geom_errorbar(aes(ymin=G$Mean-G$SE, ymax=G$Mean+G$SE), colour="black", width=.1) +
geom_point(aes(shape=Species), size = 4) +
geom_line(aes(linetype=Treatment), size = 0.5) +
xlab("Time") + #Label the X Axis
ylab("Growth % per Day") + #Label the Y Axis
theme_bw() + #Set the background color
theme(axis.line = element_line(color = 'black'), #Set the axes color
axis.title=element_text(size=14,face="bold"), #Set axis format
panel.border = element_blank(), #Set the border
panel.grid.major = element_blank(), #Set the major gridlines
panel.grid.minor = element_blank(), #Set the minor gridlines
plot.background =element_blank(), #Set the plot background
legend.key = element_blank()) #Set plot legend key
Fig16
###Repeated Measures ANOVA
G.RM <- growth.rate[,c(1,3,11:13)] #subset factor and growth data
G.RM <- melt(G.RM) #reshape into long format
G.RM$Subject <- rep(1:94, times=3) #add subject IDs
Growth.RM.lme <- lme((sqrt(value+1)) ~ variable*Treatment*Species, random = ~ variable|Subject, data=na.omit(G.RM)) #repeated measures ANOVA with random intercept but not slope (clonal fragments expect to respond the same)
Growth.results <- summary(Growth.RM.lme) #view RM ANOVA summary
Growth.stats <- anova(Growth.RM.lme) #view F and p values
Growth.RM.posthoc <- lsmeans(Growth.RM.lme, specs=c("variable","Treatment","Species")) #calculate MS means
Growth.RM.posthoc #view results
Growth.RM.posthoc.p <- contrast(Growth.RM.posthoc, method="pairwise", by=c("Species","variable")) #contrast treatment groups within a species at each time point
Growth.RM.posthoc.p #view results
###Testing ANOVA Assumptions
###Data are normally distributed
hist(RM.lme$residuals) #histogram
qqnorm(RM.lme$residuals) # normal quantile plot
#calculate backtransformed means and SE
G.RM$rate.trans <- sqrt(G.RM$value+1)
growth.trans.avg <- aggregate(rate.trans  ~ Species + Treatment + variable, data=G.RM, mean, na.rm = TRUE) #calculate the averages by Species and Treatment
growth.trans.se <- aggregate(rate.trans  ~ Species + Treatment + variable, data=G.RM, std.error, na.rm = TRUE) #calculate the standard errors by Species and Treatment
growth.trans.std <- aggregate(rate.trans  ~ Species + Treatment + variable, data=G.RM, sd, na.rm = TRUE) #calculate the standard deviation by Species and Treatment
growth.trans <- growth.trans.avg #generate dataframe of averages
colnames(growth.trans) <- c("Species", "Treatment", "Time", "avg")
growth.trans$Upper <- growth.trans$avg+growth.trans.se$rate.trans
growth.trans$Lower <- growth.trans$avg-growth.trans.se$rate.trans
back.trans.growth <- growth.trans
back.trans.growth$avg <- ((growth.trans$avg)^2)-1
back.trans.growth$Upper <- ((growth.trans$Upper)^2)-1
back.trans.growth$Lower <- ((growth.trans$Lower)^2)-1
back.trans.growth$TS <- c("MC Amb", "PD Amb", "MC High", "PD High","MC Amb", "PD Amb", "MC High", "PD High","MC Amb", "PD Amb", "MC High", "PD High")
#Plot backtransformed means and SE
Fig17 <- ggplot(back.trans.growth, aes(x=Time, y=avg, group=TS), position="dodge") +
geom_errorbar(aes(ymin=back.trans.growth$Lower, ymax=back.trans.growth$Upper), colour="black", width=.1) +
geom_point(aes(shape=Species), size = 4) +
geom_line(aes(linetype=Treatment), size = 0.5) +
xlab("Time") + #Label the X Axis
ylab("Growth % per Day") + #Label the Y Axis
ggtitle("A") + #set plot title
theme_bw() + #Set the background color
theme(axis.line = element_line(color = 'black'), #Set the axes color
axis.title=element_text(size=14,face="bold"), #Set axis format
panel.border = element_blank(), #Set the border
panel.grid.major = element_blank(), #Set the major gridlines
panel.grid.minor = element_blank(), #Set the minor gridlines
plot.background =element_blank(), #Set the plot background
legend.key = element_blank(), #Set plot legend key
plot.title=element_text(hjust=0))
Fig17
#------------------------------------------------
#DNA METHYLATION ANALYSIS
#load DNA Methylation data
data <- read.csv("BM_Methylation.csv", header=TRUE, sep=",", na.strings="NA") #load data with a header, separated by commas, with NA as NA
data <- na.omit(data) #omit data rows that include NA
counts <- aggregate(data["Methylation"], by=data[c("Species","Treatment")], FUN=length) #count the sample sizes
avg <- aggregate(Methylation ~ Species + Treatment, data=data, mean, na.rm = TRUE) #calculate the averages by Species and Treatment
se <- aggregate(Methylation ~ Species + Treatment, data=data, std.error, na.rm = TRUE) #calculate the standard errors by Species and Treatment
methyl <- cbind(avg, se$Methylation) #generate dataframe of averages and standard errors
colnames(methyl) <- c("Species", "Treatment", "avg", "se" ) #rename columns of dataframe
Fig18 <- ggplot(data=methyl, aes(x=factor(Species), y=(avg), fill=Treatment)) + #plot methylation data averages
geom_bar()+
geom_bar(stat="identity", position=position_dodge(), #use values and offset position so bars don't overlap
colour="black", # set line color,
size=.3, #set line weight
show_guide=FALSE) + #remove slash from legend
scale_fill_manual(values=c("blue", "red")) + #set fill color for bars
geom_errorbar(aes(ymin=avg-se, ymax=avg+se), #plot standard errors
width=.2,                    # set width of the error bars
position=position_dodge(.9)) + #offset position so bars don't overlap
ggtitle("B") + #set plot title
xlab("Species") + #Label the X Axis
ylab("% DNA Methylation")+ #Label the Y Axis
theme_bw() + #Set the background color
theme(axis.line = element_line(color = 'black'), #Set the axes color
panel.border = element_blank(), #Set the border
panel.grid.major = element_blank(), #Set the major gridlines
panel.grid.minor = element_blank(), #Set the minor gridlines
plot.background =element_blank(), #Set the plot background
legend.key = element_blank(), #Set plot legend key
plot.title=element_text(hjust=0)) #Justify the title to the top left
Fig18 #View figure
###Testing ANOVA Assumptions
methylation.results <- aov((Methylation^0.25) ~Treatment * Species, data=data)
methylation.stats <- anova(methylation.results)
###Testing ANOVA Assumptions
###Homogeneity of variance
#get unstandardized predicted and residual values
unstandardizedPredicted <- predict(methylation.results)
unstandardizedResiduals <- resid(methylation.results)
#get standardized values and plot to determine homogeneity
standardizedPredicted <- (unstandardizedPredicted - mean(unstandardizedPredicted)) / sd(unstandardizedPredicted)
standardizedResiduals <- (unstandardizedResiduals - mean(unstandardizedResiduals)) / sd(unstandardizedResiduals)
#create standardized residuals plot
plot(standardizedPredicted, standardizedResiduals, main = "Standardized Residuals Plot", xlab = "Standardized Predicted Values", ylab = "Standardized Residuals")
#add horizontal line
abline(0,0)
leveneTest((Methylation^0.33) ~Treatment * Species, data=data)
###Data are normally distributed
results.stdres <- rstandard(methylation.results)
qqnorm(results.stdres) # normal quantile plot
qqline(results.stdres) # adding a qline of comparison
shapiro.test(results.stdres) #runs a normality test using shapiro-wilk test on the standardized residuals
methylation.HSD <- TukeyHSD(methylation.results, ordered = FALSE, conf.level = 0.95) #calculate pairwise differences between groups using Tukey's HSD Test
methylation.HSD #View results
MCPDavg <- aggregate(Methylation ~ Species, data=data, mean, na.rm = TRUE) #Calculate methylation average for each species
MCPDavg #View results
#calculate backtransformed means and SE
data$Methylation.trans <- (data$Methylation)^0.25
sp.trans.avg <- aggregate(Methylation.trans ~ Species, data=data, mean, na.rm = TRUE) #calculate the averages by Species
sp.backtrans.avg <- (sp.trans.avg$Methylation.trans)^4 #backtransform the average
trans.avg <- aggregate(Methylation.trans ~ Species + Treatment, data=data, mean, na.rm = TRUE) #calculate the averages by Species and Treatment
trans.se <- aggregate(Methylation.trans ~ Species + Treatment, data=data, std.error, na.rm = TRUE) #calculate the standard errors by Species and Treatment
trans.std <- aggregate(Methylation.trans ~ Species + Treatment, data=data, sd, na.rm = TRUE) #calculate the standard deviation by Species and Treatment
trans.methyl <- trans.avg #generate dataframe of averages
colnames(trans.methyl) <- c("Species", "Treatment", "avg")
trans.methyl$Upper <- trans.methyl$avg+trans.se$Methylation.trans
trans.methyl$Lower <- trans.methyl$avg-trans.se$Methylation.trans
back.trans.methyl <- trans.methyl
back.trans.methyl$avg <- (trans.methyl$avg)^4
back.trans.methyl$Upper <- (trans.methyl$Upper)^4
back.trans.methyl$Lower <- (trans.methyl$Lower)^4
back.trans.methyl
#Plot backtransformed means and SE
Fig19 <- ggplot(data=back.trans.methyl, aes(x=factor(Species), y=(avg), fill=Treatment)) + #plot methylation data averages
geom_bar()+
geom_bar(stat="identity", position=position_dodge(), #use values and offset position so bars don't overlap
colour="black", # set line color,
size=.3, #set line weight
show_guide=FALSE) + #remove slash from legend
scale_fill_manual(values=c("blue", "red")) + #set fill color for bars
geom_errorbar(aes(ymin=Lower, ymax=Upper), #plot standard errors
width=.2,                    # set width of the error bars
position=position_dodge(.9)) + #offset position so bars don't overlap
ggtitle("B") + #set plot title
xlab("Species") + #Label the X Axis
ylab("% DNA Methylation")+ #Label the Y Axis
theme_bw() + #Set the background color
theme(axis.line = element_line(color = 'black'), #Set the axes color
panel.border = element_blank(), #Set the border
panel.grid.major = element_blank(), #Set the major gridlines
panel.grid.minor = element_blank(), #Set the minor gridlines
plot.background =element_blank(), #Set the plot background
legend.key = element_blank(), #Set plot legend key
plot.title=element_text(hjust=0)) #Justify the title to the top left
Fig19 #View figure
#------------------------------------------------
#CAPTURE ALL STATISTICAL OUTPUT TO A FILE
setwd(file.path(mainDir, 'Output'))
capture.output(MC.OPLSResults, PD.OPLSResults, ALL.OPLSResults, Growth.results, Growth.stats, Growth.RM.posthoc.p, methylation.results, methylation.stats, methylation.HSD, RSD.result,  file="Bulk_Methylation_Statistical_Results.txt")
Figure.S1 <- arrangeGrob(Fig3, Fig2, Fig1, ncol=3)
ggsave(file="FigureS1_Manuscript.pdf", Figure.S1, width = 11, height = 4, units = c("in"))
Figure.S2 <- arrangeGrob(Fig6, Fig9, ncol=2)
ggsave(file="FigureS2_Manuscript.pdf", Figure.S2, width = 11, height = 4, units = c("in"))
Figure.S3 <- arrangeGrob(Fig.RSD, ncol=1)
ggsave(file="FigureS3_Manuscript.pdf", Figure.S3, width = 11, height = 4, units = c("in"))
Figure.1 <- arrangeGrob(Fig11, Fig12, ncol=2)
ggsave(file="Figure1_Manuscript.pdf", Figure.1, width = 11, height = 4, units = c("in"))
Figure.2 <- arrangeGrob(Fig13, Fig14, Fig15, ncol=1)
ggsave(file="Figure2_Manuscript.pdf", Figure.2, width = 5, height = 11, units = c("in"))
Figure.3 <- arrangeGrob(Fig17, Fig19, ncol=2)
ggsave(file="Figure3_Manuscript.pdf", Figure.3, width = 11, height = 4, units = c("in"))
write.csv(PD.SigMet, 'Table_S3_SigMetabolites_Pdamicornis_Treatment_OPLSDA.csv')
write.csv(MC.SigMet, 'Table_S2_SigMetabolites_Mcapitata_Treatment_OPLSDA.csv') #write results to file
Growth.RM.lme <- lme((sqrt(value+1)) ~ variable*Treatment*Species, random = ~ 1|Subject, data=na.omit(G.RM)) #repeated measures ANOVA with random intercept but not slope (clonal fragments expect to respond the same)
Growth.results <- summary(Growth.RM.lme) #view RM ANOVA summary
Growth.stats <- anova(Growth.RM.lme) #view F and p values
Growth.stats
Growth.RM.posthoc <- lsmeans(Growth.RM.lme, specs=c("variable","Treatment","Species")) #calculate MS means
Growth.RM.posthoc #view results
Growth.RM.posthoc.p <- contrast(Growth.RM.posthoc, method="pairwise", by=c("Species","variable")) #contrast treatment groups within a species at each time point
Growth.RM.posthoc.p #view results
Growth.RM.lme <- lme((sqrt(value+1)) ~ variable*Treatment*Species, random = ~ variable|Subject, data=na.omit(G.RM)) #repeated measures ANOVA with random intercept but not slope (clonal fragments expect to respond the same)
Growth.results <- summary(Growth.RM.lme) #view RM ANOVA summary
Growth.stats <- anova(Growth.RM.lme) #view F and p values
Growth.RM.posthoc <- lsmeans(Growth.RM.lme, specs=c("variable","Treatment","Species")) #calculate MS means
Growth.RM.posthoc #view results
Growth.RM.posthoc.p <- contrast(Growth.RM.posthoc, method="pairwise", by=c("Species","variable")) #contrast treatment groups within a species at each time point
Growth.RM.posthoc.p #view results
?contrast
mean.tank.light
Fig8
tanks.light.mean
quarterly.tank.light.mean4
Fig9
tank.light.data$Tank4.quanta <- ((tank.light.data$Tank4/(15*60))*T4.lm[2])+T4.lm[1] #Apply the cross calibration of the odyssey light to Licor cosine sensor standard 192SA cosine sensor
tank.light.data$Tank4.quanta
tank.light.data$Tank4.quanta
mydate.light <- strptime(tank.light.data$Date.Time, format="%m/%d/%y %H:%M") #convert date format to characters
tank.light.data$Tank4.quanta <- (tank.light.data$Tank4/*T4.lm[2])+T4.lm[1] #Apply the cross calibration of the odyssey light to Licor cosine sensor standard 192SA cosine sensor
tank.light.data$Tank4.quanta <- (tank.light.data$Tank4*T4.lm[2])+T4.lm[1] #Apply the cross calibration of the odyssey light to Licor cosine sensor standard 192SA cosine sensor
tank.light.data$Tank4.quanta
tank.light.data <- read.csv("BM_Tank_light.csv", header=TRUE, sep=",", na.strings="NA") #load data with a header, separated by commas, with NA as NA
tank.light.data[tank.light.data==0] <- NA
mydate.light <- strptime(tank.light.data$Date.Time, format="%m/%d/%y %H:%M") #convert date format to characters
tank.light.data$Tank4.quanta <- (tank.light.data$Tank4*T4.lm[2])+T4.lm[1] #Apply the cross calibration of the odyssey light to Licor cosine sensor standard 192SA cosine sensor
tank.light.data$Tank5.quanta <-(tank.light.data$Tank5*T5.lm[2])+T5.lm[1] #Apply the cross calibration of the odyssey light to Licor cosine sensor standard 192SA cosine sensor
tank.light.data$Date.Time <-mydate.light #make a dataframe of light and time
tank.light.data
View(tank.light.data)
Fig7 <- ggplot(tank.light.data, aes(Date.Time)) + #plot tank light data
geom_line(aes(y = Tank4.quanta, colour="Ambient")) + #plot light data as a line on the Y axis with date as the X axis
geom_line(aes(y = Tank5.quanta, colour="High")) + #plot light data as a line on the Y axis with date as the X axis for additional treatment
scale_colour_manual("Treatment", values = c("blue","red")) + #color the treatment groups differently
xlab("Date") + #Label the X Axis
ylab(bquote('Irradiance ('*mu~ 'mol' ~photons ~ m^-2~s^-1*')')) + #Label the Y Axis
ggtitle("BM Tank Light") + #Label the main title
theme_bw() + #Set the background color
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), #Set the text angle
axis.line = element_line(color = 'black'), #Set the axes color
panel.border = element_blank(), #Set the border
panel.grid.major = element_blank(), #Set the major gridlines
panel.grid.minor = element_blank(), #Set the minor gridlines
plot.background =element_blank(), #Set the plot background
legend.key = element_blank()) #Set plot legend key
Fig7 #View figure
tank.light.data <- read.csv("BM_Tank_light.csv", header=TRUE, sep=",", na.strings="NA") #load data with a header, separated by commas, with NA as NA
tank.light.data[tank.light.data==0] <- NA
getwd()
setwd("/Users/hputnam/Publications/In_Review/Bulk_Methylation/Coral_DNAMethylation_Plasticity/R_Analysis/Data")
tank.light.data <- read.csv("BM_Tank_light.csv", header=TRUE, sep=",", na.strings="NA") #load data with a header, separated by commas, with NA as NA
tank.light.data[tank.light.data==0] <- NA
mydate.light <- strptime(tank.light.data$Date.Time, format="%m/%d/%y %H:%M") #convert date format to characters
tank.light.data$Tank4.quanta <- (tank.light.data$Tank4*T4.lm[2])+T4.lm[1] #Apply the cross calibration of the odyssey light to Licor cosine sensor standard 192SA cosine sensor
tank.light.data$Tank5.quanta <-(tank.light.data$Tank5*T5.lm[2])+T5.lm[1] #Apply the cross calibration of the odyssey light to Licor cosine sensor standard 192SA cosine sensor
tank.light.data$Date.Time <-mydate.light #make a dataframe of light and time
View(tank.light.data)
tank.light.data <- read.csv("BM_Tank_light.csv", header=TRUE, sep=",", na.strings="NA") #load data with a header, separated by commas, with NA as NA
tank.light.data[tank.light.data==0] <- NA
mydate.light <- strptime(tank.light.data$Date.Time, format="%m/%d/%y %H:%M") #convert date format to characters
tank.light.data$Tank4.quanta <- (tank.light.data$Tank4*T4.lm[2])+T4.lm[1] #Apply the cross calibration of the odyssey light to Licor cosine sensor standard 192SA cosine sensor
tank.light.data$Tank5.quanta <-(tank.light.data$Tank5*T5.lm[2])+T5.lm[1] #Apply the cross calibration of the odyssey light to Licor cosine sensor standard 192SA cosine sensor
tank.light.data$Date.Time <-mydate.light #make a dataframe of light and time
mydate.light
Fig7 <- ggplot(tank.light.data, aes(Date.Time)) + #plot tank light data
geom_line(aes(y = Tank4.quanta, colour="Ambient")) + #plot light data as a line on the Y axis with date as the X axis
geom_line(aes(y = Tank5.quanta, colour="High")) + #plot light data as a line on the Y axis with date as the X axis for additional treatment
scale_colour_manual("Treatment", values = c("blue","red")) + #color the treatment groups differently
xlab("Date") + #Label the X Axis
ylab(bquote('Irradiance ('*mu~ 'mol' ~photons ~ m^-2~s^-1*')')) + #Label the Y Axis
ggtitle("BM Tank Light") + #Label the main title
theme_bw() + #Set the background color
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), #Set the text angle
axis.line = element_line(color = 'black'), #Set the axes color
panel.border = element_blank(), #Set the border
panel.grid.major = element_blank(), #Set the major gridlines
panel.grid.minor = element_blank(), #Set the minor gridlines
plot.background =element_blank(), #Set the plot background
legend.key = element_blank()) #Set plot legend key
Fig7 #View figure
tank.light <- tank.light.data[, 4:5] #subset the data to tank number and light data
tank.light  <- melt(tank.light ,  na.rm=TRUE) #rearrange the data in long format removing NA or missing data
colnames(tank.light ) <- c("Tank.Number", "Tank.Light") #rename the data columns
mean.tank.light <-ddply(tank.light, .(Tank.Number), summarize, #For each subset of a data frame, apply function then combine results into a data frame.
N=length(na.omit(Tank.Light)), # the sample size of the light column summarized by Tank number
mean = (mean(Tank.Light)),       #take the average of the light column summarized by Tank number
sd = sd(Tank.Light), # the standard deviation of the temp column summarized by Tank number
sem = (sd(Tank.Light)/sqrt(length(tank.light)))) #calculate the SEM as the sd/sqrt of the count or data length
mean.tank.light # display mean and sem temp levels
mean.tank.light<-transform(mean.tank.light, lower=mean-sem, upper=mean+sem) # add the upper and lower SEM values to the dataframe
mean.tank.light #display mean and sem of light levels with lower and upper values for each tank
Fig8 <- ggplot(mean.tank.light, aes(x = Tank.Number, y = mean)) + # plot mean light by tank
geom_point(data = mean.tank.light, aes(y = mean), # points represent the mean
colour = 'black', size = 5) + # plot black points of size 5
geom_errorbar(aes(ymax=upper, ymin=lower), data=mean.tank.light) + # plot mean and sem together
xlab("Tanks") + #Label the X Axis
ylab(bquote('Irradiance ('*mu~ 'mol' ~photons ~ m^-2~s^-1*')')) + #Label the Y Axis
ggtitle("BM Average Tank Light") + #label the main title
theme_bw() + #Set the background color
theme(axis.line = element_line(color = 'black'), #Set the axes color
panel.border = element_blank(), #Set the border
panel.grid.major = element_blank(), #Set the major gridlines
panel.grid.minor = element_blank(), #Set the minor gridlines
plot.background=element_blank()) #Set the plot background
Fig8 #View figure
tanks.light.mean <- mean(tank.light$Tank.Light) #Calculate the grand average of light data
tanks.light.mean #View data
tanks.light.se <- sd(tank.light$Tank.Light)/sqrt(length(na.omit(tank.light$Tank.Light))) #Calculate the overall standard error of the light data
tanks.light.se #View data
#Plotting diurnal cycles
tank.time <- format(as.POSIXct(mydate.light) ,format = "%H:%M") #set time to hours and minutes
tank.lights <- cbind(tank.light.data, tank.time) #Combine time and light data
colnames(tank.lights) <- c("Date", "Tank4", "Tank5", "Tank4.quanta", "Tank5.quanta", "Time") #Rename columns to describe contents
tank.lights #View data
quarterly.tank.light.mean4 <- aggregate(Tank4 ~ Time, data=tank.lights, mean, na.rm=TRUE) #calculate mean of light for every 15 min interval
quarterly.tank.light.se4 <- aggregate(Tank4 ~ Time, data=tank.lights, std.error, na.rm=TRUE)  #calculate standard error of the mean of light for every 15 min interval
quarterly.tank.light.mean5 <- aggregate(Tank5 ~ Time, data=tank.lights, mean, na.rm=TRUE) #calculate mean of light for every 15 min interval
quarterly.tank.light.se5 <- aggregate(Tank5 ~ Time, data=tank.lights, std.error, na.rm=TRUE)  #calculate standard error of the mean of light for every 15 min interval
tank.light.means <- data.frame(quarterly.tank.light.mean4, quarterly.tank.light.se4$Tank4, quarterly.tank.light.mean5$Tank5, quarterly.tank.light.se5$Tank5) #combine mean and standard error results
colnames(tank.light.means) <- c("Time", "Tank4.mean", "Tank4.se", "Tank5.mean", "Tank5.se")  #Rename columns to describe contents
Fig9 <- ggplot(tank.light.means, aes(Time)) + # plot mean light by tank
geom_point(aes(y = Tank4.mean, colour="Ambient")) + #plot points
geom_errorbar(aes(x=Time, ymax=Tank4.mean+Tank4.se, ymin=Tank4.mean-Tank4.se), position=position_dodge(0.9), data=tank.light.means) + #set values for standard error bars and offset on the X axis for clarity
geom_point(aes(y = Tank5.mean, colour="High")) + #plot points
geom_errorbar(aes(x=Time, ymax=Tank5.mean+Tank5.se, ymin=Tank5.mean-Tank5.se), position=position_dodge(0.9), data=tank.light.means) + #set values for standard error bars and offset on the X axis for clarity
scale_colour_manual("Treatment", values = c("blue","red")) +
scale_x_discrete(breaks=c("0:00", "01:00", "02:00", "03:00", "04:00", "05:00", "06:00", "07:00", "08:00", "09:00", "10:00", "11:00", "12:00","13:00", "14:00", "15:00", "16:00", "17:00", "18:00","19:00", "20:00", "21:00", "22:00", "23:00")) + #set discrete breaks on the X axis
ggtitle("B") + #Label the graph
xlab("Time") + #Label the X Axis
ylab(bquote('Irradiance ('*mu~ 'mol' ~photons ~ m^-2~s^-1*')')) + #Label the Y Axis
theme_bw() + #Set the background color
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), #Set the text angle
axis.line = element_line(color = 'black'), #Set the axes color
panel.border = element_blank(), #Set the border
panel.grid.major = element_blank(), #Set the major gridlines
panel.grid.minor = element_blank(), #Set the minor gridlines
plot.background =element_blank(), #Set the plot background
legend.key = element_blank(), #Set plot legend key
plot.title=element_text(hjust=0)) #Justify the title to the top left
Fig9 #View figure
tank.light.means
quarterly.tank.light.mean4
View(tank.pCO2.means)
View(tank.lights)
View(quarterly.tank.light.mean4)
quarterly.tank.light.mean4 <- aggregate(Tank4.quanta ~ Time, data=tank.lights, mean, na.rm=TRUE) #calculate mean of light for every 15 min interval
View(quarterly.tank.light.mean4)
quarterly.tank.light.mean4 <- aggregate(Tank4.quanta ~ Time, data=tank.lights, mean, na.rm=TRUE) #calculate mean of light for every 15 min interval
quarterly.tank.light.se4 <- aggregate(Tank4.quanta ~ Time, data=tank.lights, std.error, na.rm=TRUE)  #calculate standard error of the mean of light for every 15 min interval
quarterly.tank.light.mean5 <- aggregate(Tank5.quanta ~ Time, data=tank.lights, mean, na.rm=TRUE) #calculate mean of light for every 15 min interval
quarterly.tank.light.se5 <- aggregate(Tank5.quanta ~ Time, data=tank.lights, std.error, na.rm=TRUE)  #calculate standard error of the mean of light for every 15 min interval
View(quarterly.tank.light.mean5)
View(quarterly.tank.light.mean5)
View(quarterly.tank.light.mean4)
View(quarterly.tank.light.mean5)
View(quarterly.tank.light.se4)
View(quarterly.tank.light.se5)
View(quarterly.tank.light.se4)
tank.light.means <- data.frame(quarterly.tank.light.mean4, quarterly.tank.light.se4$Tank4.quanta, quarterly.tank.light.mean5$Tank5.quanta, quarterly.tank.light.se5$Tank5.quanta) #combine mean and standard error results
View(tank.light.means)
quarterly.tank.light.mean4
View(quarterly.tank.light.mean4)
quarterly.tank.light.mean4 <- aggregate(Tank4.quanta ~ Time, data=tank.lights, mean, na.rm=TRUE) #calculate mean of light for every 15 min interval
quarterly.tank.light.se4 <- aggregate(Tank4.quanta ~ Time, data=tank.lights, std.error, na.rm=TRUE)  #calculate standard error of the mean of light for every 15 min interval
quarterly.tank.light.mean5 <- aggregate(Tank5.quanta ~ Time, data=tank.lights, mean, na.rm=TRUE) #calculate mean of light for every 15 min interval
quarterly.tank.light.se5 <- aggregate(Tank5.quanta ~ Time, data=tank.lights, std.error, na.rm=TRUE)  #calculate standard error of the mean of light for every 15 min interval
View(quarterly.tank.light.se4)
View(quarterly.tank.light.mean4)
quarterly.tank.light.mean5$Tank5.quanta
View(quarterly.tank.light.mean5)
View(quarterly.tank.light.se5)
quarterly.tank.light.mean4 <- aggregate(Tank4.quanta ~ Time, data=tank.lights, mean, na.rm=TRUE) #calculate mean of light for every 15 min interval
quarterly.tank.light.se4 <- aggregate(Tank4.quanta ~ Time, data=tank.lights, std.error, na.rm=TRUE)  #calculate standard error of the mean of light for every 15 min interval
quarterly.tank.light.mean5 <- aggregate(Tank5.quanta ~ Time, data=tank.lights, mean, na.rm=TRUE) #calculate mean of light for every 15 min interval
quarterly.tank.light.se5 <- aggregate(Tank5.quanta ~ Time, data=tank.lights, std.error, na.rm=TRUE)  #calculate standard error of the mean of light for every 15 min interval
tank.light.means <- data.frame(quarterly.tank.light.mean4, quarterly.tank.light.se4$Tank4.quanta, quarterly.tank.light.mean5$Tank5.quanta, quarterly.tank.light.se5$Tank5.quanta) #combine mean and standard error results
colnames(tank.light.means) <- c("Time", "Tank4.mean", "Tank4.se", "Tank5.mean", "Tank5.se")  #Rename columns to describe contents
tank.light.means
Fig9 <- ggplot(tank.light.means, aes(Time)) + # plot mean light by tank
geom_point(aes(y = Tank4.mean, colour="Ambient")) + #plot points
geom_errorbar(aes(x=Time, ymax=Tank4.mean+Tank4.se, ymin=Tank4.mean-Tank4.se), position=position_dodge(0.9), data=tank.light.means) + #set values for standard error bars and offset on the X axis for clarity
geom_point(aes(y = Tank5.mean, colour="High")) + #plot points
geom_errorbar(aes(x=Time, ymax=Tank5.mean+Tank5.se, ymin=Tank5.mean-Tank5.se), position=position_dodge(0.9), data=tank.light.means) + #set values for standard error bars and offset on the X axis for clarity
scale_colour_manual("Treatment", values = c("blue","red")) +
scale_x_discrete(breaks=c("0:00", "01:00", "02:00", "03:00", "04:00", "05:00", "06:00", "07:00", "08:00", "09:00", "10:00", "11:00", "12:00","13:00", "14:00", "15:00", "16:00", "17:00", "18:00","19:00", "20:00", "21:00", "22:00", "23:00")) + #set discrete breaks on the X axis
ggtitle("B") + #Label the graph
xlab("Time") + #Label the X Axis
ylab(bquote('Irradiance ('*mu~ 'mol' ~photons ~ m^-2~s^-1*')')) + #Label the Y Axis
theme_bw() + #Set the background color
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), #Set the text angle
axis.line = element_line(color = 'black'), #Set the axes color
panel.border = element_blank(), #Set the border
panel.grid.major = element_blank(), #Set the major gridlines
panel.grid.minor = element_blank(), #Set the minor gridlines
plot.background =element_blank(), #Set the plot background
legend.key = element_blank(), #Set plot legend key
plot.title=element_text(hjust=0)) #Justify the title to the top left
Fig9 #View figure
min(quarterly.tank.light.mean4$Tank4.quanta)
max(quarterly.tank.light.mean4$Tank4.quanta)
max(quarterly.tank.light.mean5$Tank5.quanta)
